diff --git a/ast_test.py b/ast_test.py
index d86d049..cd12b58 100644
--- a/ast_test.py
+++ b/ast_test.py
@@ -1,10 +1,6 @@
-from pyggi import Program, Patch, GranularityLevel, TestResult
-from pyggi.atomic_operator import StmtReplacement, StmtInsertion
-from pyggi.custom_operator import StmtDeletion, StmtMoving
-from pyggi.helper import stmt_python
-import ast
-import astor
-import copy
+from pyggi import Patch, TestResult
+from pyggi.astor import Program
+from pyggi.astor import StmtReplacement, StmtInsertion, StmtDeletion, StmtMoving
 import random
 
 # Custom parser for the results of pytest
@@ -20,8 +16,7 @@ def result_parser(stdout, stderr):
         return TestResult(False, None)
 
 # Create new Program instance for 'sample/Triangle_fast_python'
-triangle = Program(
-    "sample/Triangle_fast_python", granularity_level=GranularityLevel.AST)
+triangle = Program("sample/Triangle_fast_python")
 triangle.print_modification_points('triangle.py')
 
 # Set modification weights
diff --git a/example/improve.py b/example/improve.py
index 27a708e..64e28fd 100644
--- a/example/improve.py
+++ b/example/improve.py
@@ -6,10 +6,9 @@ Improving non-functional properties ::
 import sys
 import random
 import argparse
-from pyggi import Program, Patch, GranularityLevel
 from pyggi.algorithms import LocalSearch
-from pyggi.atomic_operator import LineReplacement, LineInsertion
-from pyggi.custom_operator import LineDeletion
+from pyggi.line import Program
+from pyggi.line import LineReplacement, LineInsertion, LineDeletion
 
 if __name__ == "__main__":
     parser = argparse.ArgumentParser(description='PYGGI Improvment Example')
@@ -20,7 +19,7 @@ if __name__ == "__main__":
         help='total iterations per epoch(default: 100)')
     args = parser.parse_args()
     
-    program = Program(args.project_path, GranularityLevel.LINE)
+    program = Program(args.project_path)
    
     class MyLocalSearch(LocalSearch):
         def get_neighbour(self, patch):
diff --git a/example/improve_python.py b/example/improve_python.py
index 805a4ab..37266fd 100644
--- a/example/improve_python.py
+++ b/example/improve_python.py
@@ -6,10 +6,10 @@ Improving non-functional properties ::
 import sys
 import random
 import argparse
-from pyggi import Program, Patch, GranularityLevel, TestResult
+from pyggi import TestResult
 from pyggi.algorithms import LocalSearch
-from pyggi.atomic_operator import LineReplacement, LineInsertion
-from pyggi.custom_operator import LineDeletion
+from pyggi.line import Program
+from pyggi.line import LineReplacement, LineInsertion, LineDeletion
 
 if __name__ == "__main__":
     parser = argparse.ArgumentParser(description='PYGGI Improvment Example')
@@ -19,9 +19,9 @@ if __name__ == "__main__":
     parser.add_argument('--iter', type=int, default=100,
         help='total iterations per epoch(default: 100)')
     args = parser.parse_args()
-    
-    program = Program(args.project_path, GranularityLevel.LINE)
-   
+
+    program = Program(args.project_path)
+
     class MyLocalSearch(LocalSearch):
         def get_neighbour(self, patch):
             if len(patch) > 0 and random.random() < 0.5:
diff --git a/example/my_improve.py b/example/my_improve.py
new file mode 100644
index 0000000..3fe26c3
--- /dev/null
+++ b/example/my_improve.py
@@ -0,0 +1,70 @@
+"""
+Improving non-functional properties ::
+
+    python improve.py ../sample/Triangle_fast
+"""
+import sys
+import random
+import argparse
+from pyggi import Patch
+from pyggi.algorithms import LocalSearch
+
+
+class MyLocalSearch(LocalSearch):
+    def set_operators(self, l):
+        assert len(l) > 0
+        self.operators = l
+
+    def get_neighbour(self, patch):
+        if len(patch) > 0 and random.random() < 0.1:
+            patch.remove(random.randrange(0, len(patch)))
+        else:
+            edit_operator = random.choice(self.operators)
+            patch.add(edit_operator.create(self.program))
+        return patch
+
+    def get_fitness(self, patch):
+        return float(patch.test_result.custom['runtime'])
+
+    def is_valid_patch(self, patch):
+        return patch.test_result.compiled and patch.test_result.custom['pass_all'] == 'true'
+
+    def stopping_criterion(self, iter, patch):
+        return float(patch.test_result.custom['runtime']) < 0.01
+
+if __name__ == "__main__":
+    parser = argparse.ArgumentParser(description='PYGGI Improvement Example')
+    parser.add_argument('project_path', type=str, default='../sample/Triangle_fast')
+    parser.add_argument('--epoch', type=int, default=30,
+                        help='total epoch (default: 30)')
+    parser.add_argument('--iter', type=int, default=100,
+                        help='total iterations per epoch (default: 100)')
+    parser.add_argument('--line', action='store_true', default=None)
+    parser.add_argument('--ast', action='store_true', default=None)
+    parser.add_argument('--xml', action='store_true', default=None)
+    args = parser.parse_args()
+
+    if args.ast:
+        from pyggi.astor import Program
+        from pyggi.astor import StmtReplacement, StmtInsertion, StmtDeletion
+        ops = [StmtDeletion, StmtInsertion, StmtReplacement]
+    elif args.xml:
+        from pyggi.xml import Program
+        from pyggi.xml import TagReplacement, TagDeletion, TagInsertion, TagMoving, TagSwap
+        from pyggi.xml import XmlReplacement, XmlDeletion, XmlInsertion, XmlMoving, XmlSwap
+        ops = [TagReplacement, TagDeletion, TagInsertion, TagMoving, TagSwap,
+               XmlReplacement, XmlDeletion, XmlInsertion, XmlMoving, XmlSwap]
+    else:
+        from pyggi.line import Program
+        from pyggi.line import LineReplacement, LineInsertion, LineDeletion
+        ops = [LineDeletion, LineInsertion, LineReplacement]
+
+    program = Program(args.project_path)
+    local_search = MyLocalSearch(program)
+    local_search.set_operators(ops)
+    result = local_search.run(warmup_reps=5, epoch=args.epoch, max_iter=args.iter,
+                              timeout=15)
+    for epoch in result:
+        print ("Epoch #{}".format(epoch))
+        for key in result[epoch]:
+            print ("- {}: {}".format(key, result[epoch][key]))
diff --git a/example/repair.py b/example/repair.py
index 54de812..a373c49 100644
--- a/example/repair.py
+++ b/example/repair.py
@@ -6,10 +6,9 @@ Automated program repair ::
 import sys
 import random
 import argparse
-from pyggi import Program, Patch, GranularityLevel
 from pyggi.algorithms import LocalSearch
-from pyggi.atomic_operator import LineReplacement, LineInsertion
-from pyggi.custom_operator import LineDeletion
+from pyggi.line import Program
+from pyggi.line import LineReplacement, LineInsertion, LineDeletion
 
 if __name__ == "__main__":
     parser = argparse.ArgumentParser(description='PYGGI Bug Repair Example')
@@ -19,8 +18,8 @@ if __name__ == "__main__":
     parser.add_argument('--iter', type=int, default=10000,
         help='total iterations per epoch(default: 10000)')
     args = parser.parse_args()
-    
-    program = Program(args.project_path, GranularityLevel.LINE)
+
+    program = Program(args.project_path)
     #program.set_modifcation_points = []
     class MyTabuSearch(LocalSearch):
         def get_neighbour(self, patch):
diff --git a/example/repair_python.py b/example/repair_python.py
index 40f0f41..9d4bbc3 100644
--- a/example/repair_python.py
+++ b/example/repair_python.py
@@ -6,10 +6,10 @@ Automated program repair ::
 import sys
 import random
 import argparse
-from pyggi import Program, Patch, GranularityLevel, TestResult
+from pyggi import TestResult
 from pyggi.algorithms import LocalSearch
-from pyggi.atomic_operator import LineReplacement, LineInsertion
-from pyggi.custom_operator import LineDeletion
+from pyggi.line import Program
+from pyggi.line import LineReplacement, LineInsertion, LineDeletion
 
 if __name__ == "__main__":
     parser = argparse.ArgumentParser(description='PYGGI Bug Repair Example')
@@ -19,8 +19,8 @@ if __name__ == "__main__":
     parser.add_argument('--iter', type=int, default=10000,
         help='total iterations per epoch(default: 10000)')
     args = parser.parse_args()
-    
-    program = Program(args.project_path, GranularityLevel.LINE)
+
+    program = Program(args.project_path)
     program.set_modification_weights('triangle.py', [1]*35)
     class MyTabuSearch(LocalSearch):
         def get_neighbour(self, patch):
diff --git a/line_test.py b/line_test.py
index cdf57c4..a56ab1f 100644
--- a/line_test.py
+++ b/line_test.py
@@ -1,6 +1,6 @@
-from pyggi import Program, Patch, GranularityLevel, TestResult
-from pyggi.atomic_operator import LineReplacement, LineInsertion
-from pyggi.custom_operator import LineDeletion, LineMoving
+from pyggi import Patch, TestResult
+from pyggi.line import Program
+from pyggi.line import LineReplacement, LineInsertion, LineDeletion, LineMoving
 import copy, random
 
 def result_parser(stdout, stderr):
@@ -14,8 +14,7 @@ def result_parser(stdout, stderr):
     else:
         return TestResult(False, None)
 
-triangle = Program(
-    "sample/Triangle_bug_python", granularity_level=GranularityLevel.LINE)
+triangle = Program("sample/Triangle_bug_python")
 # triangle.print_modification_points('triangle.py')
 
 # See sample/Triangle_bug_python/get_spectrum.py
diff --git a/pyggi/__init__.py b/pyggi/__init__.py
index 1fbb6fe..b97f204 100644
--- a/pyggi/__init__.py
+++ b/pyggi/__init__.py
@@ -2,10 +2,13 @@
 PYGGI: Python General framework for Genetic Improvement
 """
 
-from . import algorithms, atomic_operator, custom_operator
-from .program import Program, GranularityLevel
+from . import abstract
+from . import helper
 from .patch import Patch
 from .test_result import TestResult
+# from . import line
+# from . import astor
+# from . import xml
 
 def oink():
     '''
diff --git a/pyggi/abstract/__init__.py b/pyggi/abstract/__init__.py
new file mode 100644
index 0000000..2a73976
--- /dev/null
+++ b/pyggi/abstract/__init__.py
@@ -0,0 +1,4 @@
+from .algorithm import AbstractAlgorithm
+from .program import AbstractProgram
+from .atomic_operator import AbstractAtomicOperator
+from .custom_operator import AbstractCustomOperator
diff --git a/pyggi/abstract/algorithm.py b/pyggi/abstract/algorithm.py
new file mode 100644
index 0000000..a30b191
--- /dev/null
+++ b/pyggi/abstract/algorithm.py
@@ -0,0 +1,37 @@
+"""
+
+This module contains meta-heuristic search algorithms.
+
+"""
+
+from abc import ABC, abstractmethod
+
+class AbstractAlgorithm(ABC):
+    """
+    Algorithm (Abstract Class)
+
+    All children classes need to override
+
+    * :py:meth:`get_fitness`
+    """
+
+    def __init__(self, program):
+        """
+        :param program: The Program instance to optimize.
+        :type program: :py:class:`.Program`
+        """
+        self.program = program
+
+    @abstractmethod
+    def get_fitness(self, patch):
+        """
+        Define the fitness value of the patch
+
+        If you want to use original one(elapsed_time),
+        simply call ``super()``.
+
+        :param patch: The patch instacne
+        :type patch: :py:class:`.Patch`
+        :return: The fitness value
+        """
+        return patch.test_result.elapsed_time
diff --git a/pyggi/abstract/atomic_operator.py b/pyggi/abstract/atomic_operator.py
new file mode 100644
index 0000000..423d65d
--- /dev/null
+++ b/pyggi/abstract/atomic_operator.py
@@ -0,0 +1,91 @@
+"""
+
+This module contains AbstractAtomicOperator class which is an abstact base class.
+
+"""
+from abc import ABC, abstractmethod
+import ast
+import copy
+import random
+
+
+class AbstractAtomicOperator(ABC):
+    """
+
+    PYGGI-defined AbstractAtomic Operator:
+    User can generate the own custom edit operators
+    which can be converted into a list of atomic operators.
+    For example, **MOVE x -> y** operator can be represented as
+    **[LineReplacement(x, None),LineInsertion(x, y)]**
+
+    **Available List**
+
+    * LineReplacement
+    * LineInsertion
+    * StmtReplacement
+    * StmtInsertion
+
+    """
+
+    def __eq__(self, other):
+        if self.__class__.__name__ != other.__class__.__name__:
+            return False
+        for prop in self.__dict__:
+            if self.__dict__[prop] != other.__dict__[prop]:
+                return False
+        return True
+
+    @property
+    def atomic_operators(self):
+        """
+        :return: ``[self]``, the list that only contains the AbstractAtomicOperator instance itself.
+        :rtype: list(:py:class:`.atomic_operator.AbstractAtomicOperator`)
+        """
+        return [self]
+
+    @abstractmethod
+    def __init__(self):
+        pass
+
+    @abstractmethod
+    def __str__(self):
+        pass
+
+    @property
+    @abstractmethod
+    def modification_point(self):
+        pass
+
+    @abstractmethod
+    def is_valid_for(self, program):
+        """
+        :param program: The program instance to which this edit will be applied
+        :type program: :py:class:`.Program`
+        :return: Whether the edit is able to be applied to the program
+        :rtype: bool
+        """
+        pass
+
+    @abstractmethod
+    def apply(self, program, new_contents, modification_points):
+        """"
+        Apply the operator to the contents of program
+        :param program: The original program instance
+        :type program: :py:class:`.Program`
+        :param new_contents: The new contents of program to which the edit will be applied
+        :type new_contents: dict(str, list(?))
+        :param modification_points: The original modification points
+        :type modification_points: list(?)
+        :return: success or not
+        :rtype: bool
+        """
+        pass
+
+    @classmethod
+    @abstractmethod
+    def create(cls):
+        """
+        :return: The operator instance with randomly-selected properties.
+        :rtype: :py:class:`.atomic_operator.AbstractAtomicOperator`
+        """
+        pass
diff --git a/pyggi/abstract/custom_operator.py b/pyggi/abstract/custom_operator.py
new file mode 100644
index 0000000..3c98a39
--- /dev/null
+++ b/pyggi/abstract/custom_operator.py
@@ -0,0 +1,84 @@
+"""
+
+This module contains AbstractCustomOperator class which is an abstact base class,
+and several classes inherit the AbstractCustomOperator class.
+The classes are provided as examples of custom edit operator.
+
+"""
+from abc import ABC, abstractmethod
+from . import AbstractAtomicOperator
+
+
+class AbstractCustomOperator(ABC):
+    """
+    AbstractCustomOperator is an abstact class which is designed to be used
+    as a basic structure of custom edit operators.
+
+    Every class that inherits AbstractCustomOperator class must override the
+    methods marked with ``@abstractmethod`` to create instances.
+
+    * :py:meth:`__str__`
+    * :py:meth:`length_of_args`
+    * :py:meth:`atomic_operators`
+    """
+    def __init__(self, *args):
+        if len(args) != self.length_of_args:
+            raise Exception("{} takes {} positional argument but {} were given.".format(
+                self.__class__.__name__, self.length_of_args, len(args)))
+        self.args = args
+        assert isinstance(self.atomic_operators, list)
+        assert all(isinstance(op, AbstractAtomicOperator) for op in self.atomic_operators)
+
+    def __eq__(self, other):
+        return self.atomic_operators == other.atomic_operators
+
+    @property
+    def detail(self) -> str:
+        """
+        :return: The detail of this custom edit
+        :rtype: str
+
+        .. note::
+            If the edit is ``LineMoving(('Triangle.java', 10), ('Triangle.java', 4))``
+
+            returns::
+
+                1) Insert ('Triangle.java', 4) before ('Triangle.java', 10)
+                2) Replace ('Triangle.java', 4) with None
+        """
+        return "\n".join(
+            list(
+                map(lambda x: "{}) {}".format(x[0] + 1, x[1]),
+                    enumerate(self.atomic_operators))))
+
+    @abstractmethod
+    def __str__(self):
+        pass
+
+    @abstractmethod
+    def is_valid_for(self, program):
+        """
+        :param program: The program instance to which this edit will be applied
+        :type program: :py:class:`.Program`
+        :return: Whether the edit is able to be applied to the program
+        :rtype: bool
+        """
+        pass
+
+    @property
+    @abstractmethod
+    def length_of_args(self):
+        """
+        :return: The length of args the edit operator should take
+        :rtype: int
+        """
+        pass
+
+    @property
+    @abstractmethod
+    def atomic_operators(self):
+        """
+        :return: The list of instances of AbstractAtomicOperator.
+        :rtype: list(:py:class:`.atomic_operator.AbstractAtomicOperator`)
+        """
+        pass
diff --git a/pyggi/abstract/program.py b/pyggi/abstract/program.py
new file mode 100644
index 0000000..ce0ddc9
--- /dev/null
+++ b/pyggi/abstract/program.py
@@ -0,0 +1,192 @@
+"""
+
+This module contains AbstractProgram class.
+
+"""
+import json
+import os
+import random
+import shutil
+from abc import ABC, abstractmethod
+from enum import Enum
+from distutils.dir_util import copy_tree
+from ..helper import Logger
+
+class AbstractProgram(ABC):
+    """
+
+    AbstractProgram encapsulates the original source code.
+    Currently, PYGGI stores the source code as a list of code lines,
+    as lines are the only supported unit of modifications.
+    For modifications at other granularity levels,
+    this class needs to process and store the source code accordingly
+    (for example, by parsing and storing the AST).
+
+    """
+    CONFIG_FILE_NAME = 'PYGGI_CONFIG'
+    TMP_DIR = "./pyggi_tmp/"
+
+    def __init__(self, path, config_file_name=CONFIG_FILE_NAME):
+        self.path = path.strip()
+        if self.path.endswith('/'):
+            self.path = self.path[:-1]
+        self.name = os.path.basename(self.path)
+        self.logger = Logger(self.name)
+        with open(os.path.join(self.path, config_file_name)) as config_file:
+            config = json.load(config_file)
+            self.test_command = config['test_command']
+            self.target_files = config['target_files']
+        AbstractProgram.clean_tmp_dir(self.tmp_path)
+        copy_tree(self.path, self.tmp_path)
+        self.contents = self.parse(self.path, self.target_files)
+        self.modification_weights = dict()
+        self._modification_points = None
+
+    def __str__(self):
+        return self.target_files
+
+    def reset_tmp_dir(self):
+        AbstractProgram.clean_tmp_dir(self.tmp_path)
+        copy_tree(self.path, self.tmp_path)
+
+    @property
+    def tmp_path(self):
+        """
+        :return: The path of the temporary directory
+        :rtype: str
+        """
+        return os.path.join(AbstractProgram.TMP_DIR, self.name)
+
+    @property
+    @abstractmethod
+    def modification_points(self):
+        """
+        :return: The list of position of modification points for each target program
+        :rtype: dict(str, ?)
+        """
+        pass
+
+    def select_modification_point(self, target_file, method="random"):
+        """
+        :param str target_file: The modification point is chosen within target_file
+        :param str method: The way how to choose a modification point, *'random'* or *'weighted'*
+        :return: The **index** of modification point
+        :rtype: int
+        """
+        assert target_file in self.target_files
+        assert method in ['random', 'weighted']
+        candidates = self.modification_points[target_file]
+        if method == 'random' or target_file not in self.modification_weights:
+            return random.randrange(len(candidates))
+        elif method == 'weighted':
+            cumulated_weights = sum(self.modification_weights[target_file])
+            list_of_prob = list(map(lambda w: float(w)/cumulated_weights, self.modification_weights[target_file]))
+            return random.choices(list(range(len(candidates))), weights=list_of_prob, k=1)[0]
+
+    def random_location(self, target_file):
+        assert target_file in self.target_files
+        candidates = self.modification_points[target_file]
+        return random.choice(candidates)
+
+    def set_modification_weights(self, target_file, weights):
+        """
+        :param str target_file: The path to file
+        :param weights: The modification weight([0,1]) of each modification points
+        :type weights: list(float)
+        :return: None
+        :rtype: None
+        """
+        from copy import deepcopy
+        assert target_file in self.target_files
+        assert len(self.modification_points[target_file]) == len(weights)
+        assert not list(filter(lambda w: w < 0 or w > 1, weights))
+        self.modification_weights[target_file] = deepcopy(weights)
+
+    @abstractmethod
+    def print_modification_points(self, target_file, indices=None):
+        """
+        Print the source of each modification points
+
+        :param target_file: The path to target file
+        :type target_file: str
+        :return: None
+        :rtype: None
+        """
+        raise NotImplementedError
+
+    def write_to_tmp_dir(self, new_contents):
+        """
+        Write new contents to the temporary directory of program
+
+        :param new_contents: The new contents of the program.
+          Refer to *apply* method of :py:class:`.patch.Patch`
+        :type new_contents: dict(str, ?)
+        :rtype: None
+        """
+        for target_file in new_contents:
+            with open(os.path.join(self.tmp_path, target_file), 'w') as tmp_file:
+                tmp_file.write(self.to_source(new_contents[target_file]))
+
+    @classmethod
+    def clean_tmp_dir(cls, tmp_path):
+        """
+        Clean the temporary project directory if it exists.
+
+        :param str tmp_path: The path of directory to clean.
+        :return: None
+        """
+        if os.path.exists(tmp_path):
+            shutil.rmtree(tmp_path)
+        if not os.path.exists(AbstractProgram.TMP_DIR):
+            os.mkdir(AbstractProgram.TMP_DIR)
+        os.mkdir(tmp_path)
+
+    def parse(self, path, target_files):
+        """
+        :param granularity_level: The granularity level of a program
+        :type granularity_level: :py:class:`.program.GranularityLevel`
+        :param str path: The project root path
+        :param target_files: The paths to target files from the project root
+        :type target_files: list(str)
+
+        :return: The contents of the files, see `Hint`
+        :rtype: dict(str, list(str))
+
+        .. hint::
+            - key: the file name
+            - value: the contents of the file
+        """
+        raise NotImplementedError
+
+    @staticmethod
+    def is_python_code(source_path):
+        """
+        :param source_path: The path of the source file
+        :type source_path: str
+        :return: whether the file's extention is *.py* or not
+        :rtype: bool
+        """
+        return AbstractProgram.get_file_extension(source_path) == '.py'
+
+    @staticmethod
+    def get_file_extension(file_path):
+        """
+        :param file_path: The path of file
+        :type file_path: str
+        :return: file extension
+        :rtype: str
+        """
+        _, file_extension = os.path.splitext(file_path)
+        return file_extension
+
+    @staticmethod
+    def have_the_same_file_extension(file_path_1, file_path_2):
+        """
+        :param file_path_1: The path of file 1
+        :type file_path_1: str
+        :param file_path_2: The path of file 2
+        :type file_path_2: str
+        :return: same or not
+        :rtype: bool
+        """
+        return AbstractProgram.get_file_extension(file_path_1) == AbstractProgram.get_file_extension(file_path_2)
diff --git a/pyggi/algorithms/__init__.py b/pyggi/algorithms/__init__.py
new file mode 100644
index 0000000..4c21686
--- /dev/null
+++ b/pyggi/algorithms/__init__.py
@@ -0,0 +1 @@
+from .local_search import LocalSearch
diff --git a/pyggi/algorithms.py b/pyggi/algorithms/local_search.py
similarity index 89%
rename from pyggi/algorithms.py
rename to pyggi/algorithms/local_search.py
index 0838fb3..4d00275 100644
--- a/pyggi/algorithms.py
+++ b/pyggi/algorithms/local_search.py
@@ -1,14 +1,10 @@
-"""
-
-This module contains meta-heuristic search algorithms.
-
-"""
 import time
-from abc import ABCMeta, abstractmethod
-from .patch import Patch
-from .test_result import TestResult
+from abc import abstractmethod
+from ..abstract import AbstractAlgorithm
+from .. import Patch
+from .. import TestResult
 
-class LocalSearch(metaclass=ABCMeta):
+class LocalSearch(AbstractAlgorithm):
     """
     Local Search (Abstact Class)
 
@@ -34,7 +30,7 @@ class LocalSearch(metaclass=ABCMeta):
                         patch.remove(random.randrange(0, len(patch)))
                     else:
                         edit_operator = random.choice([LineDeletion, LineInsertion, LineReplacement])
-                        patch.add(edit_operator.random(program))
+                        patch.add(edit_operator.create(program))
                     return patch
 
                 def get_fitness(self, patch):
@@ -50,11 +46,7 @@ class LocalSearch(metaclass=ABCMeta):
             results = local_search.run(warmup_reps=5, epoch=3, max_iter=100, timeout=15)
     """
     def __init__(self, program):
-        """
-        :param program: The Program instance to optimize.
-        :type program: :py:class:`.Program`
-        """
-        self.program = program
+        super().__init__(program)
         self.best_fitness = None
 
     def is_valid_patch(self, patch):
@@ -102,20 +94,6 @@ class LocalSearch(metaclass=ABCMeta):
         """
         pass
 
-    @abstractmethod
-    def get_fitness(self, patch):
-        """
-        Define the fitness value of the patch
-
-        If you want to use original one(elapsed_time),
-        simply call ``super()``.
-
-        :param patch: The patch instacne
-        :type patch: :py:class:`.Patch`
-        :return: The fitness value
-        """
-        return patch.test_result.elapsed_time
-
     def run(self, warmup_reps=1, epoch=5, max_iter=100, timeout=15,
             result_parser=TestResult.pyggi_result_parser):
         """
diff --git a/pyggi/astor/__init__.py b/pyggi/astor/__init__.py
new file mode 100644
index 0000000..6b3a1d5
--- /dev/null
+++ b/pyggi/astor/__init__.py
@@ -0,0 +1,4 @@
+from .program import Program
+from .atomic_operator import StmtReplacement, StmtInsertion
+from .custom_operator import StmtDeletion, StmtMoving
+from . import stmt_python
diff --git a/pyggi/astor/atomic_operator.py b/pyggi/astor/atomic_operator.py
new file mode 100644
index 0000000..d2fabaf
--- /dev/null
+++ b/pyggi/astor/atomic_operator.py
@@ -0,0 +1,196 @@
+"""
+
+This module contains AbstractAtomicOperator class which is an abstact base class,
+and several classes inherit the AbstractAtomicOperator class.
+
+"""
+import ast
+import copy
+import random
+from ..abstract import AbstractAtomicOperator
+from . import Program as AstorProgram
+from . import stmt_python
+
+
+class StmtReplacement(AbstractAtomicOperator):
+
+    def __init__(self, stmt, ingredient=None):
+        """
+        :param stmt: The file path and the node # of statement which should be replaced
+        :type stmt: tuple(str, int)
+        :param ingredient: The file path and the node # of statement which is an ingredient
+        :type ingredient: None or tuple(str, int)
+        """
+        super().__init__()
+        assert isinstance(stmt[0], str)
+        assert isinstance(stmt[1], int)
+        assert stmt[1] >= 0
+        if ingredient:
+            assert isinstance(ingredient[0], str)
+            assert isinstance(ingredient[1], int)
+            assert ingredient[1] >= 0
+        self.stmt = stmt
+        self.ingredient = ingredient
+
+    def __str__(self):
+        """
+        :return: ``StmtReplacement([stmt], [ingredient])``
+        """
+        return "StmtReplacement({}, {})".format(self.stmt, self.ingredient)
+
+    @property
+    def modification_point(self):
+        return self.stmt
+
+    def is_valid_for(self, program):
+        return isinstance(program, AstorProgram)
+
+    def apply(self, program, new_contents, modification_points):
+        """"
+        Apply the operator to the contents of program
+        :param program: The original program instance
+        :type program: :py:class:`.Program`
+        :param new_contents: The new contents of program to which the edit will be applied
+        :type new_contents: dict(str, ?)
+        :param modification_points: The original modification points
+        :type modification_points: list(int, )
+        :return: success or not
+        :rtype: bool
+        """
+        assert self.is_valid_for(program)
+        dst_root = new_contents[self.stmt[0]]
+        dst_pos = modification_points[self.stmt[0]][self.stmt[1]]
+        if not self.ingredient:
+            return stmt_python.replace((dst_root, dst_pos), self.ingredient)
+        ingr_root = program.contents[self.ingredient[0]]
+        ingr_pos = program.modification_points[self.ingredient[0]][self.ingredient[1]]
+        return stmt_python.replace((dst_root, dst_pos), (ingr_root, ingr_pos))
+
+    @classmethod
+    def create(cls, program, stmt_file=None, ingr_file=None, del_rate=0, method='random'):
+        """
+        :param program: The program instance to which the random edit will be applied.
+        :type program: :py:class:`.Program`
+        :param str stmt_file: stmt is the target statement to delete.
+          If stmt_file is specified, the target statement will be chosen within that file.
+        :param str ingr_file: Ingredient is the statement to be copied.
+          If ingr_file is specified, the ingredient statement will be chosen within that file.
+        :param float del_rate: The probability of ingredient will be None. ([0,1])
+        :param str method: The way of choosing the modification point. **'random'** or **'weighted'**
+        :return: The StmtReplacement instance with the randomly-selected properties:
+          stmt and ingredient.
+        :rtype: :py:class:`.atomic_operator.StmtReplacement`
+        """
+        assert del_rate >= 0 and del_rate <= 1
+        stmt_file = stmt_file or random.choice(program.target_files)
+        stmt = (stmt_file, program.select_modification_point(stmt_file, method))
+        if random.random() < del_rate:
+            ingredient = None
+        else:
+            ingr_file = ingr_file or random.choice(program.target_files)
+            ingredient = (ingr_file, program.select_modification_point(ingr_file, 'random'))
+        return cls(stmt, ingredient)
+
+
+class StmtInsertion(AbstractAtomicOperator):
+
+    def __init__(self, stmt, ingredient, direction='before'):
+        """
+        :param stmt: The file path and position of statement which is a target of modification
+        :type stmt: tuple(str, list(tuple(str, int)))
+        :param ingredient: The file path and the position of statement which will be inserted
+        :type ingredient: None or tuple(str, list(tuple(str, int)))
+        :param direction: *'before'* or *'after'*
+        :type direction: str
+        """
+        super().__init__()
+        assert isinstance(stmt[0], str)
+        assert isinstance(stmt[1], int)
+        assert stmt[1] >= 0
+        assert isinstance(ingredient[0], str)
+        assert isinstance(ingredient[1], int)
+        assert ingredient[1] >= 0
+        assert direction in ['before', 'after']
+        self.stmt = stmt
+        self.ingredient = ingredient
+        self.direction = direction
+
+    def __str__(self):
+        """
+        :return: ``StmtInsertion([line], [ingredient], [direction])``
+        """
+        return "StmtInsertion({}, {}, '{}')".format(self.stmt, self.ingredient, self.direction)
+
+    @property
+    def modification_point(self):
+        return self.stmt
+
+    def is_valid_for(self, program):
+        return isinstance(program, AstorProgram)
+
+    def apply(self, program, new_contents, modification_points):
+        """
+        Apply the operator to the contents of program
+
+        :param program: The original program instance
+        :type program: :py:class:`.Program`
+        :param new_contents: The new contents of program to which the edit will be applied
+        :type new_contents: dict(str, ?)
+        :param modification_points: The original modification points
+        :type modification_points: list(int, )
+        :return: success or not
+        :rtype: bool
+        """
+        assert self.is_valid_for(program)
+        success = False
+        dst_root = new_contents[self.stmt[0]]
+        dst_pos = modification_points[self.stmt[0]][self.stmt[1]]
+        ingr_root = program.contents[self.ingredient[0]]
+        ingr_pos = stmt_python.get_modification_points(ingr_root)[self.ingredient[1]]
+        if self.direction == 'before':
+            success = stmt_python.insert_before((dst_root, dst_pos), (ingr_root, ingr_pos))
+            if success:
+                depth = len(dst_pos)
+                parent = dst_pos[:depth-1]
+                index = dst_pos[depth-1][1]
+                for pos in modification_points[self.stmt[0]]:
+                    if parent == pos[:depth-1] and len(pos) >= depth and index <= pos[depth-1][1]:
+                        a, i = pos[depth-1]
+                        pos[depth-1] = (a, i + 1)
+        elif self.direction == 'after':
+            success = stmt_python.insert_after((dst_root, dst_pos), (ingr_root, ingr_pos))
+            if success:
+                depth = len(dst_pos)
+                parent = dst_pos[:depth-1]
+                index = dst_pos[depth - 1][1]
+                for pos in modification_points[self.stmt[0]]:
+                    if parent == pos[:depth-1] and len(pos) >= depth and index < pos[depth-1][1]:
+                        a, i = pos[depth-1]
+                        pos[depth-1] = (a, i + 1)
+        return success
+
+    @classmethod
+    def create(cls, program, stmt_file=None, ingr_file=None, direction='before', method='random'):
+        """
+        :param program: The program instance to which the random edit will be applied.
+        :type program: :py:class:`.Program`
+        :param str line_file: stmt means the modification point of the edit.
+          If stmt_file is specified, the stmt will be chosen within that file.
+        :param str ingr_file: Ingredient is the stmt to be copied.
+          If ingr_file is specified, the target stmt will be chosen within that file.
+        :param str method: The way of choosing the modification point. **'random'** or **'weighted'**
+        :return: The StmtInsertion instance with the randomly-selected properties:
+          stmt and ingredient.
+        :rtype: :py:class:`.atomic_operator.StmtInsertion`
+        """
+        stmt_file = stmt_file or random.choice(program.target_files)
+        ingr_file = ingr_file or random.choice(program.target_files)
+        stmt = (
+            stmt_file,
+            program.select_modification_point(stmt_file, method)
+        )
+        ingredient = (
+            ingr_file,
+            program.select_modification_point(ingr_file, 'random')
+        )
+        return cls(stmt, ingredient, direction)
diff --git a/pyggi/astor/custom_operator.py b/pyggi/astor/custom_operator.py
new file mode 100644
index 0000000..de5a7f9
--- /dev/null
+++ b/pyggi/astor/custom_operator.py
@@ -0,0 +1,142 @@
+from ..abstract import AbstractCustomOperator
+from . import Program as AstorProgram
+
+
+class StmtDeletion(AbstractCustomOperator):
+    """
+    StmtDeletion: Delete x (Actually, Replace x with an empty statement)
+    """
+    def __str__(self):
+        return "StmtDeletion({})".format(self.x)
+
+    def is_valid_for(self, program):
+        return isinstance(program, AstorProgram)
+
+    @property
+    def x(self):
+        """
+        Delete **x**
+
+        :return: The file path and the index of modification point to be deleted.
+        :rtype: tuple(str, int)
+        """
+        return self.args[0]
+
+    @property
+    def length_of_args(self):
+        """
+        :return: ``1``
+        :rtype: int
+        """
+        return 1
+
+    @property
+    def atomic_operators(self):
+        """
+        :return: ``[StmtReplacement(self.x, None)]``
+        :rtype: list(:py:class:`.atomic_operator.AtomicOperator`)
+        """
+        from .atomic_operator import StmtReplacement
+        return [StmtReplacement(self.x, None)]
+
+    @classmethod
+    def create(cls, program, stmt_file=None, method='random'):
+        """
+        :param program: The program instance to which the created custom operator will be applied.
+        :type program: :py:class:`.Program`
+        :param str stmt_file: stmt is the target statement to delete.
+          If stmt_file is specified, the target statement will be chosen within that file.
+        :param str method: The way of choosing the modification point. **'random'** or **'weighted'**
+        :return: The StmtDeletion instance with the randomly-selected modification point.
+        :rtype: :py:class:`.custom_operator.StmtDeletion`
+        """
+        import random
+        stmt_file = stmt_file or random.choice(program.target_files)
+        stmt = (
+            stmt_file,
+            program.select_modification_point(stmt_file, method)
+        )
+        return cls(stmt)
+
+class StmtMoving(AbstractCustomOperator):
+    """
+    StmtMoving: Move x [before|after] y
+    """
+    def __str__(self):
+        return "StmtMoving({}, {}, '{}')".format(self.y, self.x, self.direction)
+
+    def is_valid_for(self, program):
+        return isinstance(program, AstorProgram)
+
+    @property
+    def x(self):
+        """
+        Move **x** [before|after] y
+
+        :return: The file path and the index of ingredient statement to be moved.
+        :rtype: tuple(str, int)
+        """
+        return self.args[1]
+
+    @property
+    def y(self):
+        """
+        Move x [before|after] **y**
+
+        :return: The file path and the index of modification point.
+        :rtype: tuple(str, int)
+        """
+        return self.args[0]
+
+    @property
+    def direction(self):
+        """
+        Move x **[before|after]** y
+
+        :return: **'before'** or **'after'**
+        :rtype: str
+        """
+        return self.args[2]
+
+    @property
+    def length_of_args(self):
+        """
+        :return: ``3``
+        :rtype: int
+        """
+        return 3
+
+    @property
+    def atomic_operators(self):
+        """
+        :return: ``[StmtInsertion(self.y, self.x, self.direction), StmtReplacement(self.x, None)]``
+        :rtype: list(:py:class:`.atomic_operator.AtomicOperator`)
+        """
+        from .atomic_operator import StmtInsertion, StmtReplacement
+        return [StmtInsertion(self.y, self.x, self.direction), StmtReplacement(self.x, None)]
+
+    @classmethod
+    def create(cls, program, stmt_file=None, ingr_file=None, direction='before', method='random'):
+        """
+        :param program: The program instance to which the created custom operator will be applied.
+        :type program: :py:class:`.Program`
+        :param str stmt_file: stmt means the modification point of the edit.
+          If stmt_file is specified, the statement will be chosen within that file.
+        :param str ingr_file: Ingredient is the statement to be moved.
+          If ingr_file is specified, the ingredient statement will be chosen within that file.
+        :param str method: The way of choosing the modification point. **'random'** or **'weighted'**
+        :return: The StmtMoving instance with the randomly-selected stmt & ingr.
+        :rtype: :py:class:`.custom_operator.StmtMoving`
+        """
+        import random
+        stmt_file = stmt_file or random.choice(program.target_files)
+        ingr_file = ingr_file or random.choice(program.target_files)
+        stmt = (
+            stmt_file,
+            program.select_modification_point(stmt_file, method)
+        )
+        ingredient = (
+            ingr_file,
+            program.select_modification_point(ingr_file, 'random')
+        )
+        return cls(ingredient, stmt, direction)
diff --git a/pyggi/astor/program.py b/pyggi/astor/program.py
new file mode 100644
index 0000000..82c6c44
--- /dev/null
+++ b/pyggi/astor/program.py
@@ -0,0 +1,77 @@
+import os
+import ast
+import astor
+from ..abstract import AbstractProgram
+from . import stmt_python
+
+class Program(AbstractProgram):
+    @property
+    def modification_points(self):
+        """
+        :return: The list of position of modification points for each target program
+        :rtype: dict(str, ?)
+        """
+        if self._modification_points:
+            return self._modification_points
+
+        self._modification_points = dict()
+        for target_file in self.target_files:
+            self._modification_points[target_file] = stmt_python.get_modification_points(
+                self.contents[target_file])
+        return self._modification_points
+
+    def print_modification_points(self, target_file, indices=None):
+        """
+        Print the source of each modification points
+
+        :param target_file: The path to target file
+        :type target_file: str
+        :return: None
+        :rtype: None
+        """
+        title_format = "=" * 25 + " {}: {} {} " + "=" * 25
+        contents = self.contents[target_file]
+        points = self.modification_points[target_file]
+        if not indices:
+            indices = range(len(points))
+        for i in indices:
+            print(title_format.format(target_file, 'node', i))
+            print(points[i])
+            blk, idx = stmt_python.pos_2_block_n_index(contents, points[i])
+            print(astor.to_source(blk[idx]))
+
+    def to_source(self, contents_of_file):
+        """
+        Change contents of file to the source code
+
+        :type granularity_level: :py:class:`GranularityLevel`
+        :param contents_of_file: The contents of the file which is the parsed form of source code
+        :type contents_of_file: ?
+        :return: The source code
+        :rtype: str
+        """
+        return astor.to_source(contents_of_file)
+
+    def parse(self, path, target_files):
+        """
+        :param granularity_level: The granularity level of a program
+        :type granularity_level: :py:class:`.program.GranularityLevel`
+        :param str path: The project root path
+        :param target_files: The paths to target files from the project root
+        :type target_files: list(str)
+
+        :return: The contents of the files, see `Hint`
+        :rtype: dict(str, list(str))
+
+        .. hint::
+            - key: the file name
+            - value: the contents of the file
+        """
+        contents = {}
+        for target in target_files:
+            if Program.is_python_code(target):
+                root = astor.parse_file(os.path.join(path, target))
+                contents[target] = root
+            else:
+                raise Exception('Program', '{} file is not supported'.format(Program.get_file_extension(target)))
+        return contents
diff --git a/pyggi/helper/stmt_python.py b/pyggi/astor/stmt_python.py
similarity index 100%
rename from pyggi/helper/stmt_python.py
rename to pyggi/astor/stmt_python.py
diff --git a/pyggi/atomic_operator.py b/pyggi/atomic_operator.py
deleted file mode 100644
index f23c080..0000000
--- a/pyggi/atomic_operator.py
+++ /dev/null
@@ -1,513 +0,0 @@
-"""
-
-This module contains AtomicOperator class which is an abstact base class,
-and several classes inherit the AtomicOperator class.
-
-"""
-from abc import ABCMeta, abstractmethod
-from .program import Program
-import ast
-
-
-class AtomicOperator(metaclass=ABCMeta):
-    """
-    
-    PYGGI-defined Atomic Operator:
-    User can generate the own custom edit operators
-    which can be converted into a list of atomic operators.
-    For example, **MOVE x -> y** operator can be represented as
-    **[LineReplacement(x, None),LineInsertion(x, y)]**
-
-    **Available List**
-
-    * LineReplacement
-    * LineInsertion
-    * StmtReplacement
-    * StmtInsertion
-
-    """
-
-    def __eq__(self, other):
-        if self.__class__.__name__ != other.__class__.__name__:
-            return False
-        for prop in self.__dict__:
-            if self.__dict__[prop] != other.__dict__[prop]:
-                return False
-        return True
-
-    @property
-    def atomic_operators(self):
-        """
-        :return: ``[self]``, the list that only contains the AtomicOperator instance itself.
-        :rtype: list(:py:class:`.atomic_operator.AtomicOperator`)
-        """
-        return [self]
-
-    @abstractmethod
-    def __init__(self):
-        pass
-
-    @abstractmethod
-    def __str__(self):
-        pass
-
-    @property
-    @abstractmethod
-    def modification_point(self):
-        pass
-
-    @abstractmethod
-    def is_valid_for(self, program):
-        """
-        :param program: The program instance to which this edit will be applied
-        :type program: :py:class:`.Program`
-        :return: Whether the edit is able to be applied to the program
-        :rtype: bool
-        """
-        pass
-
-    @abstractmethod
-    def apply(self, program, new_contents, modification_points):
-        """"
-        Apply the operator to the contents of program
-        :param program: The original program instance
-        :type program: :py:class:`.Program`
-        :param new_contents: The new contents of program to which the edit will be applied
-        :type new_contents: dict(str, list(?))
-        :param modification_points: The original modification points
-        :type modification_points: list(?)
-        :return: success or not
-        :rtype: bool
-        """
-        pass
-
-    @classmethod
-    @abstractmethod
-    def create(cls):
-        """
-        :return: The operator instance with randomly-selected properties.
-        :rtype: :py:class:`.atomic_operator.AtomicOperator`
-        """
-        pass
-
-
-class LineReplacement(AtomicOperator):
-    """
-    .. note::
-        1. LineReplacement((*[file_path]*, 3), (*[file_path]*, 2))
-
-        ======== ========
-        Before   After
-        ======== ========
-        0        0
-        1        1
-        2        2
-        3        2
-        4        4
-        ======== ========
-
-        2. LineReplacement((*[file_path]*, 3), None)
-
-        ======== ========
-        Before   After
-        ======== ========
-        0        0
-        1        1
-        2        2
-        3        4
-        4
-        ======== ========
-    """
-
-    def __init__(self, line, ingredient=None):
-        """
-        :param line: The file path and index of line which should be replaced
-        :type line: tuple(str, int)
-        :param ingredient: The file path and index of code line which is an ingredient
-        :type ingredient: None or tuple(str, int)
-        """
-        super().__init__()
-        assert isinstance(line[0], str)
-        assert isinstance(line[1], int)
-        assert line[1] >= 0
-        if ingredient:
-            assert isinstance(ingredient[0], str)
-            assert isinstance(ingredient[1], int)
-            assert ingredient[1] >= 0
-        self.line = line
-        self.ingredient = ingredient
-
-    def __str__(self):
-        """
-        :return: ``LineReplacement([line], [ingredient])``
-        """
-        return "LineReplacement({}, {})".format(self.line, self.ingredient)
-
-    @property
-    def modification_point(self):
-        return self.line
-
-    def is_valid_for(self, program):
-        from .program import GranularityLevel
-        if program.granularity_level == GranularityLevel.LINE:
-            return True
-        return False
-
-    def apply(self, program, new_contents, modification_points):
-        """"
-        Apply the operator to the contents of program
-        :param program: The original program instance
-        :type program: :py:class:`.Program`
-        :param new_contents: The new contents of program to which the edit will be applied
-        :type new_contents: dict(str, list(str))
-        :param modification_points: The original modification points
-        :type modification_points: list(int)
-        :return: success or not
-        :rtype: bool
-        """
-        assert self.is_valid_for(program)
-        l_f, l_n = self.line # line file and line number
-        if self.ingredient:
-            i_f, i_n = self.ingredient
-            new_contents[l_f][modification_points[l_f][l_n]] = program.contents[i_f][i_n]
-        else:
-            new_contents[l_f][modification_points[l_f][l_n]] = ''
-        return modification_points
-
-    @classmethod
-    def create(cls, program, line_file=None, ingr_file=None, del_rate=0, method='random'):
-        """
-        :param program: The program instance to which the random edit will be applied.
-        :type program: :py:class:`.Program`
-        :param str line_file: Line is the target line to delete.
-          If line_file is specified, the target line will be chosen within the file.
-        :param str ingr_file: Ingredient is the line to be copied.
-          If ingr_file is specified, the target line will be chosen within the file.
-        :param float del_rate: The probability of that line is deleted
-          instead of replaced with another line
-        :param str method: The way of choosing the modification point. **'random'** or **'weighted'**
-        :return: The LineReplacement instance with the randomly-selected properties:
-          line and ingredient.
-        :rtype: :py:class:`.atomic_operator.LineReplacement`
-        """
-        import random
-        assert del_rate >= 0 and del_rate <= 1
-        line_file = line_file or random.choice(program.target_files)
-        line = (line_file, program.select_modification_point(line_file, method))
-        if random.random() < del_rate:
-            ingredient = None
-        else:
-            ingr_file = ingr_file or random.choice(program.target_files)
-            ingredient = (ingr_file, program.select_modification_point(ingr_file, 'random'))
-        return cls(line, ingredient)
-
-
-class LineInsertion(AtomicOperator):
-    """
-    .. note::
-        1. LineInsertion((*[file_path]*, 4), (*[file_path]*, 2))
-
-        ======== ========
-        Before   After
-        ======== ========
-        0        0
-        1        1
-        2        2
-        3        3
-        4        2
-        ...      4
-        ======== ========
-    """
-
-    def __init__(self, line, ingredient, direction='before'):
-        """
-        :param line: The file path and position of line which is a target of modification
-        :type line: tuple(str, int)
-        :param ingredient: The file path and index of code line which is an ingredient
-        :type ingredient: tuple(str, int)
-        :param direction: *'before'* or *'after'*
-        :type direction: str
-        """
-        super().__init__()
-        assert isinstance(line[0], str)
-        assert isinstance(line[1], int)
-        assert line[1] >= 0
-        assert isinstance(ingredient[0], str)
-        assert isinstance(ingredient[1], int)
-        assert ingredient[1] >= 0
-        assert direction in ['before', 'after']
-        self.line = line
-        self.ingredient = ingredient
-        self.direction = direction
-
-    def __str__(self):
-        return "LineInsertion({}, {}, '{}')".format(self.line, self.ingredient, self.direction)
-
-    @property
-    def modification_point(self):
-        return self.line
-    
-    def is_valid_for(self, program):
-        from .program import GranularityLevel
-        if program.granularity_level == GranularityLevel.LINE:
-            return True
-        return False
-
-    def apply(self, program, new_contents, modification_points):
-        """"
-        Apply the operator to the contents of program
-        :param program: The original program instance
-        :type program: :py:class:`.Program`
-        :param new_contents: The new contents of program to which the edit will be applied
-        :type new_contents: dict(str, list(str))
-        :param modification_points: The original modification points
-        :type modification_points: list(int)
-        :return: success or not
-        :rtype: bool
-        """
-        assert self.is_valid_for(program)
-        l_f, l_n = self.line
-        i_f, i_n = self.ingredient
-        if self.direction == 'before':
-            new_contents[l_f].insert(
-                modification_points[l_f][l_n],
-                program.contents[i_f][i_n]
-            )
-            for i in range(l_n, len(modification_points[l_f])):
-                modification_points[l_f][i] += 1
-        elif self.direction == 'after':
-            new_contents[l_f].insert(
-                modification_points[l_f][l_n] + 1,
-                program.contents[i_f][i_n]
-            )
-            for i in range(l_n + 1, len(modification_points[l_f])):
-                modification_points[l_f][i] += 1
-        return True
-
-    @classmethod
-    def create(cls, program, line_file=None, ingr_file=None, direction='before', method='random'):
-        """
-        :param program: The program instance to which the random edit will be applied.
-        :type program: :py:class:`.Program`
-        :param str line_file: Line means the modification point of the edit.
-          If line_file is specified, the line will be chosen within the file.
-        :param str ingr_file: Ingredient is the line to be copied.
-          If ingr_file is specified, the target line will be chosen within the file.
-        :param str method: The way of choosing the modification point. **'random'** or **'weighted'**
-        :return: The LineInsertion instance with the randomly-selected properties:
-          line and ingredient.
-        :rtype: :py:class:`.atomic_operator.LineInsertion`
-        """
-        import random
-        line_file = line_file or random.choice(program.target_files)
-        ingr_file = ingr_file or random.choice(program.target_files)
-        line = (
-            line_file,
-            program.select_modification_point(line_file, method)
-        )
-        ingredient = (
-            ingr_file,
-            program.select_modification_point(ingr_file, 'random')
-        )
-        return cls(line, ingredient, direction)
-
-
-class StmtReplacement(AtomicOperator):
-
-    def __init__(self, stmt, ingredient=None):
-        """
-        :param stmt: The file path and the node # of statement which should be replaced
-        :type stmt: tuple(str, int)
-        :param ingredient: The file path and the node # of statement which is an ingredient
-        :type ingredient: None or tuple(str, int)
-        """
-        super().__init__()
-        assert isinstance(stmt[0], str)
-        assert isinstance(stmt[1], int)
-        assert stmt[1] >= 0
-        if ingredient:
-            assert isinstance(ingredient[0], str)
-            assert isinstance(ingredient[1], int)
-            assert ingredient[1] >= 0
-        self.stmt = stmt
-        self.ingredient = ingredient
-
-    def __str__(self):
-        """
-        :return: ``StmtReplacement([stmt], [ingredient])``
-        """
-        return "StmtReplacement({}, {})".format(self.stmt, self.ingredient)
-
-    @property
-    def modification_point(self):
-        return self.stmt
-
-    def is_valid_for(self, program):
-        from .program import GranularityLevel
-        if program.granularity_level == GranularityLevel.AST:
-            return True
-        return False
-
-    def apply(self, program, new_contents, modification_points):
-        """"
-        Apply the operator to the contents of program
-        :param program: The original program instance
-        :type program: :py:class:`.Program`
-        :param new_contents: The new contents of program to which the edit will be applied
-        :type new_contents: dict(str, ?)
-        :param modification_points: The original modification points
-        :type modification_points: list(int, )
-        :return: success or not
-        :rtype: bool
-        """
-        assert self.is_valid_for(program)
-        assert not self.ingredient or Program.have_the_same_file_extension(
-            self.stmt[0], self.ingredient[0])
-        if Program.is_python_code(self.stmt[0]):
-            from .helper import stmt_python
-            dst_root = new_contents[self.stmt[0]]
-            dst_pos = modification_points[self.stmt[0]][self.stmt[1]]
-            if not self.ingredient:
-                return stmt_python.replace((dst_root, dst_pos), self.ingredient)
-            ingr_root = program.contents[self.ingredient[0]]
-            ingr_pos = program.modification_points[self.ingredient[0]][self.ingredient[1]]
-            return stmt_python.replace((dst_root, dst_pos), (ingr_root, ingr_pos))
-        return False
-
-    @classmethod
-    def create(cls, program, stmt_file=None, ingr_file=None, del_rate=0, method='random'):
-        """
-        :param program: The program instance to which the random edit will be applied.
-        :type program: :py:class:`.Program`
-        :param str stmt_file: stmt is the target statement to delete.
-          If stmt_file is specified, the target statement will be chosen within that file.
-        :param str ingr_file: Ingredient is the statement to be copied.
-          If ingr_file is specified, the ingredient statement will be chosen within that file.
-        :param float del_rate: The probability of ingredient will be None. ([0,1])
-        :param str method: The way of choosing the modification point. **'random'** or **'weighted'**
-        :return: The StmtReplacement instance with the randomly-selected properties:
-          stmt and ingredient.
-        :rtype: :py:class:`.atomic_operator.StmtReplacement`
-        """
-        import random
-        assert del_rate >= 0 and del_rate <= 1
-        stmt_file = stmt_file or random.choice(program.target_files)
-        stmt = (stmt_file, program.select_modification_point(stmt_file, method))
-        if random.random() < del_rate:
-            ingredient = None
-        else:
-            ingr_file = ingr_file or random.choice(program.target_files)
-            ingredient = (ingr_file, program.select_modification_point(ingr_file, 'random'))
-        return cls(stmt, ingredient)
-
-
-class StmtInsertion(AtomicOperator):
-
-    def __init__(self, stmt, ingredient, direction='before'):
-        """
-        :param stmt: The file path and position of statement which is a target of modification
-        :type stmt: tuple(str, list(tuple(str, int)))
-        :param ingredient: The file path and the position of statement which will be inserted
-        :type ingredient: None or tuple(str, list(tuple(str, int)))
-        :param direction: *'before'* or *'after'*
-        :type direction: str
-        """
-        super().__init__()
-        assert isinstance(stmt[0], str)
-        assert isinstance(stmt[1], int)
-        assert stmt[1] >= 0
-        assert isinstance(ingredient[0], str)
-        assert isinstance(ingredient[1], int)
-        assert ingredient[1] >= 0
-        assert direction in ['before', 'after']
-        self.stmt = stmt
-        self.ingredient = ingredient
-        self.direction = direction
-
-    def __str__(self):
-        """
-        :return: ``StmtInsertion([line], [ingredient], [direction])``
-        """
-        return "StmtInsertion({}, {}, '{}')".format(self.stmt, self.ingredient, self.direction)
-
-    @property
-    def modification_point(self):
-        return self.stmt
-
-    def is_valid_for(self, program):
-        from .program import GranularityLevel
-        if program.granularity_level == GranularityLevel.AST:
-            return True
-        return False
-
-    def apply(self, program, new_contents, modification_points):
-        """
-        Apply the operator to the contents of program
-
-        :param program: The original program instance
-        :type program: :py:class:`.Program`
-        :param new_contents: The new contents of program to which the edit will be applied
-        :type new_contents: dict(str, ?)
-        :param modification_points: The original modification points
-        :type modification_points: list(int, )
-        :return: success or not
-        :rtype: bool
-        """
-        assert self.is_valid_for(program)
-        assert Program.have_the_same_file_extension(self.stmt[0],
-            self.ingredient[0])
-        success = False
-        if Program.is_python_code(self.stmt[0]):
-            from .helper import stmt_python
-            dst_root = new_contents[self.stmt[0]]
-            dst_pos = modification_points[self.stmt[0]][self.stmt[1]]
-            ingr_root = program.contents[self.ingredient[0]]
-            ingr_pos = stmt_python.get_modification_points(ingr_root)[self.ingredient[1]]
-            if self.direction == 'before':
-                success = stmt_python.insert_before((dst_root, dst_pos), (ingr_root, ingr_pos))
-                if success:
-                    depth = len(dst_pos)
-                    parent = dst_pos[:depth-1]
-                    index = dst_pos[depth-1][1]
-                    for pos in modification_points[self.stmt[0]]:
-                        if parent == pos[:depth-1] and len(pos) >= depth and index <= pos[depth-1][1]:
-                            a, i = pos[depth-1]
-                            pos[depth-1] = (a, i + 1)
-            elif self.direction == 'after':
-                success = stmt_python.insert_after((dst_root, dst_pos), (ingr_root, ingr_pos))
-                if success:
-                    depth = len(dst_pos)
-                    parent = dst_pos[:depth-1]
-                    index = dst_pos[depth - 1][1]
-                    for pos in modification_points[self.stmt[0]]:
-                        if parent == pos[:depth-1] and len(pos) >= depth and index < pos[depth-1][1]:
-                            a, i = pos[depth-1]
-                            pos[depth-1] = (a, i + 1)
-        return success
-
-    @classmethod
-    def create(cls, program, stmt_file=None, ingr_file=None, direction='before', method='random'):
-        """
-        :param program: The program instance to which the random edit will be applied.
-        :type program: :py:class:`.Program`
-        :param str line_file: stmt means the modification point of the edit.
-          If stmt_file is specified, the stmt will be chosen within that file.
-        :param str ingr_file: Ingredient is the stmt to be copied.
-          If ingr_file is specified, the target stmt will be chosen within that file.
-        :param str method: The way of choosing the modification point. **'random'** or **'weighted'**
-        :return: The StmtInsertion instance with the randomly-selected properties:
-          stmt and ingredient.
-        :rtype: :py:class:`.atomic_operator.StmtInsertion`
-        """
-        import random
-        stmt_file = stmt_file or random.choice(program.target_files)
-        ingr_file = ingr_file or random.choice(program.target_files)
-        stmt = (
-            stmt_file,
-            program.select_modification_point(stmt_file, method)
-        )
-        ingredient = (
-            ingr_file,
-            program.select_modification_point(ingr_file, 'random')
-        )
-        return cls(stmt, ingredient, direction)
diff --git a/pyggi/custom_operator.py b/pyggi/custom_operator.py
deleted file mode 100644
index 686edc3..0000000
--- a/pyggi/custom_operator.py
+++ /dev/null
@@ -1,374 +0,0 @@
-"""
-
-This module contains CustomOperator class which is an abstact base class,
-and several classes inherit the CustomOperator class.
-The classes are provided as examples of custom edit operator.
-
-"""
-from abc import ABCMeta, abstractmethod
-from .atomic_operator import AtomicOperator
-
-class CustomOperator(metaclass=ABCMeta):
-    """
-    CustomOperator is an abstact class which is designed to be used
-    as a basic structure of custom edit operators.
-
-    Every class that inherits CustomOperator class must override the
-    methods marked with ``@abstractmethod`` to create instances.
-
-    * :py:meth:`__str__`
-    * :py:meth:`length_of_args`
-    * :py:meth:`atomic_operators`
-    """
-    def __init__(self, *args):
-        if len(args) != self.length_of_args:
-            raise Exception("{} takes {} positional argument but {} were given.".format(
-                self.__class__.__name__, self.length_of_args, len(args)))
-        self.args = args
-        assert isinstance(self.atomic_operators, list)
-        assert all(isinstance(op, AtomicOperator) for op in self.atomic_operators)
-
-    def __eq__(self, other):
-        return self.atomic_operators == other.atomic_operators
-
-    @property
-    def detail(self) -> str:
-        """
-        :return: The detail of this custom edit
-        :rtype: str
-
-        .. note::
-            If the edit is ``LineMoving(('Triangle.java', 10), ('Triangle.java', 4))``
-
-            returns::
-
-                1) Insert ('Triangle.java', 4) before ('Triangle.java', 10)
-                2) Replace ('Triangle.java', 4) with None
-        """
-        return "\n".join(
-            list(
-                map(lambda x: "{}) {}".format(x[0] + 1, x[1]),
-                    enumerate(self.atomic_operators))))
-
-    @abstractmethod
-    def __str__(self):
-        pass
-
-    @abstractmethod
-    def is_valid_for(self, program):
-        """
-        :param program: The program instance to which this edit will be applied
-        :type program: :py:class:`.Program`
-        :return: Whether the edit is able to be applied to the program
-        :rtype: bool
-        """
-        pass
-
-    @property
-    @abstractmethod
-    def length_of_args(self):
-        """
-        :return: The length of args the edit operator should take
-        :rtype: int
-        """
-        pass
-
-    @property
-    @abstractmethod
-    def atomic_operators(self):
-        """
-        :return: The list of instances of AtomicOperator.
-        :rtype: list(:py:class:`.atomic_operator.AtomicOperator`)
-        """
-        pass
-
-class LineDeletion(CustomOperator):
-    """
-    LineDeletion: Delete x
-    
-    It replaces the code line with an empty line.
-    """
-    def __str__(self):
-        return "LineDeletion({})".format(self.x)
-
-    def is_valid_for(self, program):
-        from .program import GranularityLevel
-        if program.granularity_level == GranularityLevel.LINE:
-            return True
-        return False
-
-    @property
-    def x(self):
-        """
-        Delete **x**
-
-        :return: The file path and the index of target line to be deleted.
-        :rtype: tuple(str, int)
-        """
-        return self.args[0]
-
-    @property
-    def length_of_args(self):
-        """
-        :return: ``1``
-        :rtype: int
-        """
-        return 1
-
-    @property
-    def atomic_operators(self):
-        """
-        :return: ``[LineReplacement(self.x, None)]``
-        :rtype: list(:py:class:`.atomic_operator.AtomicOperator`)
-        """
-        from .atomic_operator import LineReplacement
-        return [LineReplacement(self.x, None)]
-
-    @classmethod
-    def create(cls, program, line_file=None, method='random'):
-        """
-        :param program: The program instance to which the random custom operator will be applied.
-        :type program: :py:class:`.Program`
-        :param str line_file: Line is the target line to delete.
-          If line_file is specified, the target line will be chosen within the file.
-        :param str method: The way of choosing the modification point. **'random'** or **'weighted'**
-        :return: The LineDeletion instance with the randomly-selected line index.
-        :rtype: :py:class:`.custom_operator.LineDeletion`
-        """
-        import random
-        line_file = line_file or random.choice(program.target_files)
-        line = (
-            line_file,
-            program.select_modification_point(line_file, method)
-        )
-        return cls(line)
-
-class LineMoving(CustomOperator):
-    """
-    LineMoving: Move x [before|after] y
-    """
-    def __str__(self):
-        return "LineMoving({}, {}, '{}')".format(self.y, self.x, self.direction)
-
-    def is_valid_for(self, program):
-        from .program import GranularityLevel
-        if program.granularity_level == GranularityLevel.LINE:
-            return True
-        return False
-
-    @property
-    def x(self):
-        """
-        Move **x** [before|after] y
-
-        :return: The file path and the index of target line to be moved.
-        :rtype: tuple(str, int)
-        """
-        return self.args[1]
-
-    @property
-    def y(self):
-        """
-        Move x [before|after] **y**
-
-        :return: The file path and the index of the point to which line x is inserted.
-        :rtype: tuple(str, int)
-        """
-        return self.args[0]
-
-    @property
-    def direction(self):
-        """
-        Move x **[before|after]** y
-
-        :return: **'before'** or **'after'**
-        :rtype: str
-        """
-        return self.args[2]
-
-    @property
-    def length_of_args(self):
-        """
-        :return: ``3``
-        :rtype: int
-        """
-        return 3
-
-    @property
-    def atomic_operators(self):
-        """
-        :return: ``[LineInsertion(self.y, self.x, self.direction), LineReplacement(self.x, None)]``
-        :rtype: list(:py:class:`.atomic_operator.AtomicOperator`)
-        """
-        from .atomic_operator import LineInsertion, LineReplacement
-        return [LineInsertion(self.y, self.x, self.direction), LineReplacement(self.x, None)]
-
-    @classmethod
-    def create(cls, program, line_file=None, ingr_file=None, direction='before', method='random'):
-        """
-        :param program: The program instance to which the created custom operator will be applied.
-        :type program: :py:class:`.Program`
-        :param str line_file: Line means the modification point of the edit. If line_file is specified, the line will be chosen within the file.
-        :param str ingr_file: Ingredient is the line to be moved.
-          If ingr_file is specified, the ingredient line will be chosen within the file.
-        :param str method: The way of choosing the modification point. **'random'** or **'weighted'**
-        :return: The LineMoving instance with the randomly-selected line & ingr.
-        :rtype: :py:class:`.custom_operator.LineMoving`
-        """
-        import random
-        line_file = line_file or random.choice(program.target_files)
-        ingr_file = ingr_file or random.choice(program.target_files)
-        line = (
-            line_file,
-            program.select_modification_point(line_file, method)
-        )
-        ingredient = (
-            ingr_file,
-            program.select_modification_point(ingr_file, 'random')
-        )
-        return cls(ingredient, line, direction)
-
-class StmtDeletion(CustomOperator):
-    """
-    StmtDeletion: Delete x (Actually, Replace x with an empty statement)
-    """
-    def __str__(self):
-        return "StmtDeletion({})".format(self.x)
-
-    def is_valid_for(self, program):
-        from .program import GranularityLevel
-        if program.granularity_level == GranularityLevel.AST:
-            return True
-        return False
-
-    @property
-    def x(self):
-        """
-        Delete **x**
-
-        :return: The file path and the index of modification point to be deleted.
-        :rtype: tuple(str, int)
-        """
-        return self.args[0]
-
-    @property
-    def length_of_args(self):
-        """
-        :return: ``1``
-        :rtype: int
-        """
-        return 1
-
-    @property
-    def atomic_operators(self):
-        """
-        :return: ``[StmtReplacement(self.x, None)]``
-        :rtype: list(:py:class:`.atomic_operator.AtomicOperator`)
-        """
-        from .atomic_operator import StmtReplacement
-        return [StmtReplacement(self.x, None)]
-
-    @classmethod
-    def create(cls, program, stmt_file=None, method='random'):
-        """
-        :param program: The program instance to which the created custom operator will be applied.
-        :type program: :py:class:`.Program`
-        :param str stmt_file: stmt is the target statement to delete.
-          If stmt_file is specified, the target statement will be chosen within that file.
-        :param str method: The way of choosing the modification point. **'random'** or **'weighted'**
-        :return: The StmtDeletion instance with the randomly-selected modification point.
-        :rtype: :py:class:`.custom_operator.StmtDeletion`
-        """
-        import random
-        stmt_file = stmt_file or random.choice(program.target_files)
-        stmt = (
-            stmt_file,
-            program.select_modification_point(stmt_file, method)
-        )
-        return cls(stmt)
-
-class StmtMoving(CustomOperator):
-    """
-    StmtMoving: Move x [before|after] y
-    """
-    def __str__(self):
-        return "StmtMoving({}, {}, '{}')".format(self.y, self.x, self.direction)
-
-    def is_valid_for(self, program):
-        from .program import GranularityLevel
-        if program.granularity_level == GranularityLevel.AST:
-            return True
-        return False
-
-    @property
-    def x(self):
-        """
-        Move **x** [before|after] y
-
-        :return: The file path and the index of ingredient statement to be moved.
-        :rtype: tuple(str, int)
-        """
-        return self.args[1]
-
-    @property
-    def y(self):
-        """
-        Move x [before|after] **y**
-
-        :return: The file path and the index of modification point.
-        :rtype: tuple(str, int)
-        """
-        return self.args[0]
-
-    @property
-    def direction(self):
-        """
-        Move x **[before|after]** y
-
-        :return: **'before'** or **'after'**
-        :rtype: str
-        """
-        return self.args[2]
-
-    @property
-    def length_of_args(self):
-        """
-        :return: ``3``
-        :rtype: int
-        """
-        return 3
-
-    @property
-    def atomic_operators(self):
-        """
-        :return: ``[StmtInsertion(self.y, self.x, self.direction), StmtReplacement(self.x, None)]``
-        :rtype: list(:py:class:`.atomic_operator.AtomicOperator`)
-        """
-        from .atomic_operator import StmtInsertion, StmtReplacement
-        return [StmtInsertion(self.y, self.x, self.direction), StmtReplacement(self.x, None)]
-
-    @classmethod
-    def create(cls, program, stmt_file=None, ingr_file=None, direction='before', method='random'):
-        """
-        :param program: The program instance to which the created custom operator will be applied.
-        :type program: :py:class:`.Program`
-        :param str stmt_file: stmt means the modification point of the edit.
-          If stmt_file is specified, the statement will be chosen within that file.
-        :param str ingr_file: Ingredient is the statement to be moved.
-          If ingr_file is specified, the ingredient statement will be chosen within that file.
-        :param str method: The way of choosing the modification point. **'random'** or **'weighted'**
-        :return: The StmtMoving instance with the randomly-selected stmt & ingr.
-        :rtype: :py:class:`.custom_operator.StmtMoving`
-        """
-        import random
-        stmt_file = stmt_file or random.choice(program.target_files)
-        ingr_file = ingr_file or random.choice(program.target_files)
-        stmt = (
-            stmt_file,
-            program.select_modification_point(stmt_file, method)
-        )
-        ingredient = (
-            ingr_file,
-            program.select_modification_point(ingr_file, 'random')
-        )
-        return cls(ingredient, stmt, direction)
diff --git a/pyggi/helper/__init__.py b/pyggi/helper/__init__.py
index e69de29..92a2f16 100644
--- a/pyggi/helper/__init__.py
+++ b/pyggi/helper/__init__.py
@@ -0,0 +1 @@
+from .logger import Logger
diff --git a/pyggi/logger.py b/pyggi/helper/logger.py
similarity index 100%
rename from pyggi/logger.py
rename to pyggi/helper/logger.py
diff --git a/pyggi/line/__init__.py b/pyggi/line/__init__.py
new file mode 100644
index 0000000..c1038a9
--- /dev/null
+++ b/pyggi/line/__init__.py
@@ -0,0 +1,3 @@
+from .program import Program
+from .atomic_operator import LineReplacement, LineInsertion
+from .custom_operator import LineDeletion, LineMoving
diff --git a/pyggi/line/atomic_operator.py b/pyggi/line/atomic_operator.py
new file mode 100644
index 0000000..6dcdbac
--- /dev/null
+++ b/pyggi/line/atomic_operator.py
@@ -0,0 +1,220 @@
+import copy
+import random
+from ..abstract import AbstractAtomicOperator
+from . import Program as LineProgram
+
+
+class LineReplacement(AbstractAtomicOperator):
+    """
+    .. note::
+        1. LineReplacement((*[file_path]*, 3), (*[file_path]*, 2))
+
+        ======== ========
+        Before   After
+        ======== ========
+        0        0
+        1        1
+        2        2
+        3        2
+        4        4
+        ======== ========
+
+        2. LineReplacement((*[file_path]*, 3), None)
+
+        ======== ========
+        Before   After
+        ======== ========
+        0        0
+        1        1
+        2        2
+        3        4
+        4
+        ======== ========
+    """
+
+    def __init__(self, line, ingredient=None):
+        """
+        :param line: The file path and index of line which should be replaced
+        :type line: tuple(str, int)
+        :param ingredient: The file path and index of code line which is an ingredient
+        :type ingredient: None or tuple(str, int)
+        """
+        super().__init__()
+        assert isinstance(line[0], str)
+        assert isinstance(line[1], int)
+        assert line[1] >= 0
+        if ingredient:
+            assert isinstance(ingredient[0], str)
+            assert isinstance(ingredient[1], int)
+            assert ingredient[1] >= 0
+        self.line = line
+        self.ingredient = ingredient
+
+    def __str__(self):
+        """
+        :return: ``LineReplacement([line], [ingredient])``
+        """
+        return "LineReplacement({}, {})".format(self.line, self.ingredient)
+
+    @property
+    def modification_point(self):
+        return self.line
+
+    def is_valid_for(self, program):
+        return isinstance(program, LineProgram)
+
+    def apply(self, program, new_contents, modification_points):
+        """"
+        Apply the operator to the contents of program
+        :param program: The original program instance
+        :type program: :py:class:`.Program`
+        :param new_contents: The new contents of program to which the edit will be applied
+        :type new_contents: dict(str, list(str))
+        :param modification_points: The original modification points
+        :type modification_points: list(int)
+        :return: success or not
+        :rtype: bool
+        """
+        assert self.is_valid_for(program)
+        l_f, l_n = self.line # line file and line number
+        if self.ingredient:
+            i_f, i_n = self.ingredient
+            new_contents[l_f][modification_points[l_f][l_n]] = program.contents[i_f][i_n]
+        else:
+            new_contents[l_f][modification_points[l_f][l_n]] = ''
+        return modification_points
+
+    @classmethod
+    def create(cls, program, line_file=None, ingr_file=None, del_rate=0, method='random'):
+        """
+        :param program: The program instance to which the random edit will be applied.
+        :type program: :py:class:`.Program`
+        :param str line_file: Line is the target line to delete.
+          If line_file is specified, the target line will be chosen within the file.
+        :param str ingr_file: Ingredient is the line to be copied.
+          If ingr_file is specified, the target line will be chosen within the file.
+        :param float del_rate: The probability of that line is deleted
+          instead of replaced with another line
+        :param str method: The way of choosing the modification point. **'random'** or **'weighted'**
+        :return: The LineReplacement instance with the randomly-selected properties:
+          line and ingredient.
+        :rtype: :py:class:`.atomic_operator.LineReplacement`
+        """
+        import random
+        assert del_rate >= 0 and del_rate <= 1
+        line_file = line_file or random.choice(program.target_files)
+        line = (line_file, program.select_modification_point(line_file, method))
+        if random.random() < del_rate:
+            ingredient = None
+        else:
+            ingr_file = ingr_file or random.choice(program.target_files)
+            ingredient = (ingr_file, program.select_modification_point(ingr_file, 'random'))
+        return cls(line, ingredient)
+
+
+class LineInsertion(AbstractAtomicOperator):
+    """
+    .. note::
+        1. LineInsertion((*[file_path]*, 4), (*[file_path]*, 2))
+
+        ======== ========
+        Before   After
+        ======== ========
+        0        0
+        1        1
+        2        2
+        3        3
+        4        2
+        ...      4
+        ======== ========
+    """
+
+    def __init__(self, line, ingredient, direction='before'):
+        """
+        :param line: The file path and position of line which is a target of modification
+        :type line: tuple(str, int)
+        :param ingredient: The file path and index of code line which is an ingredient
+        :type ingredient: tuple(str, int)
+        :param direction: *'before'* or *'after'*
+        :type direction: str
+        """
+        super().__init__()
+        assert isinstance(line[0], str)
+        assert isinstance(line[1], int)
+        assert line[1] >= 0
+        assert isinstance(ingredient[0], str)
+        assert isinstance(ingredient[1], int)
+        assert ingredient[1] >= 0
+        assert direction in ['before', 'after']
+        self.line = line
+        self.ingredient = ingredient
+        self.direction = direction
+
+    def __str__(self):
+        return "LineInsertion({}, {}, '{}')".format(self.line, self.ingredient, self.direction)
+
+    @property
+    def modification_point(self):
+        return self.line
+
+    def is_valid_for(self, program):
+        return isinstance(program, LineProgram)
+
+    def apply(self, program, new_contents, modification_points):
+        """"
+        Apply the operator to the contents of program
+        :param program: The original program instance
+        :type program: :py:class:`.Program`
+        :param new_contents: The new contents of program to which the edit will be applied
+        :type new_contents: dict(str, list(str))
+        :param modification_points: The original modification points
+        :type modification_points: list(int)
+        :return: success or not
+        :rtype: bool
+        """
+        assert self.is_valid_for(program)
+        l_f, l_n = self.line
+        i_f, i_n = self.ingredient
+        if self.direction == 'before':
+            new_contents[l_f].insert(
+                modification_points[l_f][l_n],
+                program.contents[i_f][i_n]
+            )
+            for i in range(l_n, len(modification_points[l_f])):
+                modification_points[l_f][i] += 1
+        elif self.direction == 'after':
+            new_contents[l_f].insert(
+                modification_points[l_f][l_n] + 1,
+                program.contents[i_f][i_n]
+            )
+            for i in range(l_n + 1, len(modification_points[l_f])):
+                modification_points[l_f][i] += 1
+        return True
+
+    @classmethod
+    def create(cls, program, line_file=None, ingr_file=None, direction='before', method='random'):
+        """
+        :param program: The program instance to which the random edit will be applied.
+        :type program: :py:class:`.Program`
+        :param str line_file: Line means the modification point of the edit.
+          If line_file is specified, the line will be chosen within the file.
+        :param str ingr_file: Ingredient is the line to be copied.
+          If ingr_file is specified, the target line will be chosen within the file.
+        :param str method: The way of choosing the modification point. **'random'** or **'weighted'**
+        :return: The LineInsertion instance with the randomly-selected properties:
+          line and ingredient.
+        :rtype: :py:class:`.atomic_operator.LineInsertion`
+        """
+        import random
+        line_file = line_file or random.choice(program.target_files)
+        ingr_file = ingr_file or random.choice(program.target_files)
+        line = (
+            line_file,
+            program.select_modification_point(line_file, method)
+        )
+        ingredient = (
+            ingr_file,
+            program.select_modification_point(ingr_file, 'random')
+        )
+        return cls(line, ingredient, direction)
+
diff --git a/pyggi/line/custom_operator.py b/pyggi/line/custom_operator.py
new file mode 100644
index 0000000..c1148cd
--- /dev/null
+++ b/pyggi/line/custom_operator.py
@@ -0,0 +1,143 @@
+from ..abstract import AbstractCustomOperator
+from . import Program as LineProgram
+
+
+class LineDeletion(AbstractCustomOperator):
+    """
+    LineDeletion: Delete x
+
+    It replaces the code line with an empty line.
+    """
+    def __str__(self):
+        return "LineDeletion({})".format(self.x)
+
+    def is_valid_for(self, program):
+        return isinstance(program, LineProgram)
+
+    @property
+    def x(self):
+        """
+        Delete **x**
+
+        :return: The file path and the index of target line to be deleted.
+        :rtype: tuple(str, int)
+        """
+        return self.args[0]
+
+    @property
+    def length_of_args(self):
+        """
+        :return: ``1``
+        :rtype: int
+        """
+        return 1
+
+    @property
+    def atomic_operators(self):
+        """
+        :return: ``[LineReplacement(self.x, None)]``
+        :rtype: list(:py:class:`.atomic_operator.AtomicOperator`)
+        """
+        from .atomic_operator import LineReplacement
+        return [LineReplacement(self.x, None)]
+
+    @classmethod
+    def create(cls, program, line_file=None, method='random'):
+        """
+        :param program: The program instance to which the random custom operator will be applied.
+        :type program: :py:class:`.Program`
+        :param str line_file: Line is the target line to delete.
+          If line_file is specified, the target line will be chosen within the file.
+        :param str method: The way of choosing the modification point. **'random'** or **'weighted'**
+        :return: The LineDeletion instance with the randomly-selected line index.
+        :rtype: :py:class:`.custom_operator.LineDeletion`
+        """
+        import random
+        line_file = line_file or random.choice(program.target_files)
+        line = (
+            line_file,
+            program.select_modification_point(line_file, method)
+        )
+        return cls(line)
+
+class LineMoving(AbstractCustomOperator):
+    """
+    LineMoving: Move x [before|after] y
+    """
+    def __str__(self):
+        return "LineMoving({}, {}, '{}')".format(self.y, self.x, self.direction)
+
+    def is_valid_for(self, program):
+        return isinstance(program, LineProgram)
+
+    @property
+    def x(self):
+        """
+        Move **x** [before|after] y
+
+        :return: The file path and the index of target line to be moved.
+        :rtype: tuple(str, int)
+        """
+        return self.args[1]
+
+    @property
+    def y(self):
+        """
+        Move x [before|after] **y**
+
+        :return: The file path and the index of the point to which line x is inserted.
+        :rtype: tuple(str, int)
+        """
+        return self.args[0]
+
+    @property
+    def direction(self):
+        """
+        Move x **[before|after]** y
+
+        :return: **'before'** or **'after'**
+        :rtype: str
+        """
+        return self.args[2]
+
+    @property
+    def length_of_args(self):
+        """
+        :return: ``3``
+        :rtype: int
+        """
+        return 3
+
+    @property
+    def atomic_operators(self):
+        """
+        :return: ``[LineInsertion(self.y, self.x, self.direction), LineReplacement(self.x, None)]``
+        :rtype: list(:py:class:`.atomic_operator.AtomicOperator`)
+        """
+        from .atomic_operator import LineInsertion, LineReplacement
+        return [LineInsertion(self.y, self.x, self.direction), LineReplacement(self.x, None)]
+
+    @classmethod
+    def create(cls, program, line_file=None, ingr_file=None, direction='before', method='random'):
+        """
+        :param program: The program instance to which the created custom operator will be applied.
+        :type program: :py:class:`.Program`
+        :param str line_file: Line means the modification point of the edit. If line_file is specified, the line will be chosen within the file.
+        :param str ingr_file: Ingredient is the line to be moved.
+          If ingr_file is specified, the ingredient line will be chosen within the file.
+        :param str method: The way of choosing the modification point. **'random'** or **'weighted'**
+        :return: The LineMoving instance with the randomly-selected line & ingr.
+        :rtype: :py:class:`.custom_operator.LineMoving`
+        """
+        import random
+        line_file = line_file or random.choice(program.target_files)
+        ingr_file = ingr_file or random.choice(program.target_files)
+        line = (
+            line_file,
+            program.select_modification_point(line_file, method)
+        )
+        ingredient = (
+            ingr_file,
+            program.select_modification_point(ingr_file, 'random')
+        )
+        return cls(ingredient, line, direction)
diff --git a/pyggi/line/program.py b/pyggi/line/program.py
new file mode 100644
index 0000000..667374b
--- /dev/null
+++ b/pyggi/line/program.py
@@ -0,0 +1,77 @@
+import os
+from ..abstract import AbstractProgram
+
+class Program(AbstractProgram):
+    def __str__(self):
+        code = ''
+        for k in sorted(self.contents.keys()):
+            for idx, line in enumerate(self.contents[k]):
+                code += "{}\t: {}\t: {}\n".format(k, idx, line)
+        return code
+
+    @property
+    def modification_points(self):
+        """
+        :return: The list of position of modification points for each target program
+        :rtype: dict(str, ?)
+        """
+        if self._modification_points:
+            return self._modification_points
+
+        self._modification_points = dict()
+        for target_file in self.target_files:
+            self._modification_points[target_file] = list(range(len(self.contents[target_file])))
+        return self._modification_points
+
+    def print_modification_points(self, target_file, indices=None):
+        """
+        Print the source of each modification points
+
+        :param target_file: The path to target file
+        :type target_file: str
+        :return: None
+        :rtype: None
+        """
+        title_format = "=" * 25 + " {}: {} {} " + "=" * 25
+        contents = self.contents[target_file]
+        points = self.modification_points[target_file]
+        if not indices:
+            indices = range(len(points))
+        for i in indices:
+            print(title_format.format(target_file, 'line', i))
+            print(contents[points[i]])
+            print()
+
+    def to_source(self, contents_of_file):
+        """
+        Change contents of file to the source code
+
+        :type granularity_level: :py:class:`GranularityLevel`
+        :param contents_of_file: The contents of the file which is the parsed form of source code
+        :type contents_of_file: ?
+        :return: The source code
+        :rtype: str
+        """
+        return '\n'.join(contents_of_file) + '\n'
+
+    def parse(self, path, target_files):
+        """
+        :param granularity_level: The granularity level of a program
+        :type granularity_level: :py:class:`.program.GranularityLevel`
+        :param str path: The project root path
+        :param target_files: The paths to target files from the project root
+        :type target_files: list(str)
+
+        :return: The contents of the files, see `Hint`
+        :rtype: dict(str, list(str))
+
+        .. hint::
+            - key: the file name
+            - value: the contents of the file
+        """
+        contents = {}
+        for target in target_files:
+            with open(os.path.join(path, target), 'r') as target_file:
+                contents[target] = list(
+                    map(str.rstrip, target_file.readlines()))
+        return contents
diff --git a/pyggi/patch.py b/pyggi/patch.py
index fb04226..b02c8ca 100644
--- a/pyggi/patch.py
+++ b/pyggi/patch.py
@@ -3,9 +3,7 @@ This module contains Patch class.
 """
 import os
 from copy import deepcopy
-from .program import Program, GranularityLevel
-from .atomic_operator import AtomicOperator
-from .custom_operator import CustomOperator
+from .abstract import AbstractAtomicOperator, AbstractCustomOperator
 from .test_result import TestResult
 
 
@@ -117,7 +115,7 @@ class Patch:
         :type edit: :py:class:`.atomic_operator.AtomicOperator` or :py:class:`.custom_operator.CustomOperator`
         :return: None
         """
-        assert isinstance(edit, (AtomicOperator, CustomOperator))
+        assert isinstance(edit, (AbstractAtomicOperator, AbstractCustomOperator))
         assert edit.is_valid_for(self.program)
         self.edit_list.append(edit)
 
@@ -145,7 +143,7 @@ class Patch:
                 if not atomic_class_name or atomic_class_name == atomic.__class__.__name__:
                     atomics.append(atomic)
         return atomics
-    
+
     def apply(self):
         """
         This method applies the patch to the target program.
@@ -159,7 +157,6 @@ class Patch:
             - key: The target file name(path) related to the program root path
             - value: The contents of the file
         """
-        assert isinstance(self.program.granularity_level, GranularityLevel)
         target_files = self.program.contents.keys()
         modification_points = deepcopy(self.program.modification_points)
         new_contents = deepcopy(self.program.contents)
@@ -170,5 +167,5 @@ class Patch:
         #self.program.reset_tmp_dir()
         for target_file in new_contents:
             with open(os.path.join(self.program.tmp_path, target_file), 'w') as tmp_file:
-                tmp_file.write(Program.to_source(self.program.granularity_level, new_contents[target_file]))
+                tmp_file.write(self.program.to_source(new_contents[target_file]))
         return new_contents
diff --git a/pyggi/program.py b/pyggi/program.py
deleted file mode 100644
index e8ec4d6..0000000
--- a/pyggi/program.py
+++ /dev/null
@@ -1,306 +0,0 @@
-"""
-
-This module contains GranularityLevel and Program class.
-
-"""
-import os
-import shutil
-import json
-from enum import Enum
-from distutils.dir_util import copy_tree
-from .logger import Logger
-
-
-class GranularityLevel(Enum):
-    """
-
-    GranularityLevel represents the granularity levels of program.
-
-    """
-    LINE = 'line'
-    AST = 'AST'
-
-    @classmethod
-    def is_valid(cls, value):
-        """
-        :param value: The value of enum to check
-
-        :return: Whether there is an enum that has a value equal to the `value`
-        :rtype: bool
-
-        .. hint::
-            There are some examples,
-            ::
-                GranularityLevel.is_valid('line')
-                >> True
-                GranularityLevel.is_valid('random_text')
-                >> False
-        """
-        return any(value == item.value for item in cls)
-
-
-class Program(object):
-    """
-
-    Program encapsulates the original source code.
-    Currently, PYGGI stores the source code as a list of code lines,
-    as lines are the only supported unit of modifications.
-    For modifications at other granularity levels,
-    this class needs to process and store the source code accordingly
-    (for example, by parsing and storing the AST).
-
-    """
-    CONFIG_FILE_NAME = 'PYGGI_CONFIG'
-    TMP_DIR = "./pyggi_tmp/"
-
-    def __init__(self, path, granularity_level=GranularityLevel.LINE,
-                 config_file_name=CONFIG_FILE_NAME):
-        assert isinstance(granularity_level, GranularityLevel)
-        self.path = path.strip()
-        if self.path.endswith('/'):
-            self.path = self.path[:-1]
-        self.name = os.path.basename(self.path)
-        self.logger = Logger(self.name)
-        self.granularity_level = granularity_level
-        with open(os.path.join(self.path, config_file_name)) as config_file:
-            config = json.load(config_file)
-            self.test_command = config['test_command']
-            self.target_files = config['target_files']
-        Program.clean_tmp_dir(self.tmp_path)
-        copy_tree(self.path, self.tmp_path)
-        self.contents = Program.parse(self.granularity_level, self.path, self.target_files)
-        self.modification_weights = dict()
-        self._modification_points = None
-
-    def __str__(self):
-        if self.granularity_level == GranularityLevel.LINE:
-            code = ''
-            for k in sorted(self.contents.keys()):
-                idx = 0
-                for line in self.contents[k]:
-                    code += "{}\t: {}\t: {}\n".format(k, idx, line)
-                    idx += 1
-            return code
-        return self.target_files
-
-    def reset_tmp_dir(self):
-        Program.clean_tmp_dir(self.tmp_path)
-        copy_tree(self.path, self.tmp_path)
-
-    @property
-    def tmp_path(self):
-        """
-        :return: The path of the temporary dirctory
-        :rtype: str
-        """
-        return os.path.join(Program.TMP_DIR, self.name)
-
-    @property
-    def modification_points(self):
-        """
-        :return: The list of position of modification points for each target program
-        :rtype: dict(str, ?)
-        """
-        assert isinstance(self.granularity_level, GranularityLevel)
-
-        if self._modification_points:
-            return self._modification_points
-
-        self._modification_points = dict()
-        if self.granularity_level == GranularityLevel.LINE:
-            for target_file in self.target_files:
-                self._modification_points[target_file] = list(range(len(self.contents[target_file])))
-        elif self.granularity_level == GranularityLevel.AST:
-            for target_file in self.target_files:
-                if Program.is_python_code(target_file):
-                    from .helper import stmt_python
-                    self._modification_points[target_file] = stmt_python.get_modification_points(
-                        self.contents[target_file])
-        return self._modification_points
-
-    def select_modification_point(self, target_file, method="random"):
-        """
-        :param str target_file: The modification point is chosen within target_file
-        :param str method: The way how to choose a modification point, *'random'* or *'weighted'*
-        :return: The **index** of modification point
-        :rtype: int
-        """
-        import random
-        assert target_file in self.target_files
-        assert method in ['random', 'weighted']
-        candidates = self.modification_points[target_file]
-        if method == 'random' or target_file not in self.modification_weights:
-            return random.randrange(len(candidates))
-        elif method == 'weighted':
-            cumulated_weights = sum(self.modification_weights[target_file])
-            list_of_prob = list(map(lambda w: float(w)/cumulated_weights, self.modification_weights[target_file]))
-            return random.choices(list(range(len(candidates))), weights=list_of_prob, k=1)[0]
-
-    def set_modification_weights(self, target_file, weights):
-        """
-        :param str target_file: The path to file
-        :param weights: The modification weight([0,1]) of each modification points
-        :type weights: list(float)
-        :return: None
-        :rtype: None
-        """
-        from copy import deepcopy
-        assert target_file in self.target_files
-        assert len(self.modification_points[target_file]) == len(weights)
-        assert not list(filter(lambda w: w < 0 or w > 1, weights))
-        self.modification_weights[target_file] = deepcopy(weights)
-
-    def write_to_tmp_dir(self, new_contents):
-        """
-        Write new contents to the temporary directory of program
-
-        :param new_contents: The new contents of the program.
-          Refer to *apply* method of :py:class:`.patch.Patch`
-        :type new_contents: dict(str, ?)
-        :rtype: None
-        """
-        for target_file in new_contents:
-            with open(os.path.join(self.tmp_path, target_file), 'w') as tmp_file:
-                tmp_file.write(Program.to_source(self.granularity_level, new_contents[target_file]))
-
-    def print_modification_points(self, target_file, indices=None):
-        """
-        Print the source of each modification points
-
-        :param target_file: The path to target file
-        :type target_file: str
-        :return: None
-        :rtype: None
-        """
-        title_format = "=" * 25 + " {} {} " + "=" * 25
-        if not indices:
-            indices = range(len(self.modification_points[target_file]))
-        if self.granularity_level == GranularityLevel.LINE:
-            def print_modification_point(contents, modification_points, i):
-                print(title_format.format('line', i))
-                print(contents[modification_points[i]])
-        elif self.granularity_level == GranularityLevel.AST:
-            if Program.is_python_code(target_file):
-                def print_modification_point(contents, modification_points, i):
-                    import astor
-                    from .helper import stmt_python
-                    print(title_format.format('node', i))
-                    blk, idx = stmt_python.pos_2_block_n_index(contents, modification_points[i])
-                    print(astor.to_source(blk[idx]))
-        for i in indices:
-            print_modification_point(self.contents[target_file], self.modification_points[target_file], i)
-
-    @classmethod
-    def to_source(cls, granularity_level, contents_of_file):
-        """
-        Change contents of file to the source code
-
-        :param granularity_level: The parsing level of the program
-        :type granularity_level: :py:class:`GranularityLevel`
-        :param contents_of_file: The contents of the file which is the parsed form of source code
-        :type contents_of_file: ?
-        :return: The source code
-        :rtype: str
-        """
-        if granularity_level == GranularityLevel.LINE:
-            return '\n'.join(contents_of_file) + '\n'
-        elif granularity_level == GranularityLevel.AST:
-            import astor
-            return astor.to_source(contents_of_file)
-        return ''
-
-    @classmethod
-    def clean_tmp_dir(cls, tmp_path):
-        """
-        Clean the temporary project directory if it exists.
-
-        :param str tmp_path: The path of directory to clean.
-        :return: None
-        """
-        if os.path.exists(tmp_path):
-            shutil.rmtree(tmp_path)
-        if not os.path.exists(Program.TMP_DIR):
-            os.mkdir(Program.TMP_DIR)
-        os.mkdir(tmp_path)
-
-    @classmethod
-    def parse(cls, granularity_level, path, target_files):
-        """
-        :param granularity_level: The granularity level of a program
-        :type granularity_level: :py:class:`.program.GranularityLevel`
-        :param str path: The project root path
-        :param target_files: The paths to target files from the project root
-        :type target_files: list(str)
-
-        :return: The contents of the files, see `Hint`
-        :rtype: dict(str, list(str))
-
-        .. hint::
-            - key: the file name
-            - value: the contents of the file
-        """
-        assert isinstance(granularity_level, GranularityLevel)
-        if granularity_level == GranularityLevel.LINE:
-            contents = {}
-            for target in target_files:
-                with open(os.path.join(path, target), 'r') as target_file:
-                    contents[target] = list(
-                        map(str.rstrip, target_file.readlines()))
-            return contents
-        elif granularity_level == GranularityLevel.AST:
-            import ast
-            import astor
-            contents = {}
-            for target in target_files:
-                if cls.is_python_code(target):
-                    root = astor.parse_file(os.path.join(path, target))
-                    contents[target] = root
-                else:
-                    raise Exception('Program', '{} file is not supported'.format(cls.get_file_extension(target)))
-            return contents
-        return None
-
-    @staticmethod
-    def is_python_code(source_path):
-        """
-        :param source_path: The path of the source file
-        :type source_path: str
-        :return: whether the file's extention is *.py* or not
-        :rtype: bool
-        """
-        _, file_extension = os.path.splitext(source_path)
-        return file_extension == '.py'
-
-    @staticmethod
-    def is_java_code(source_path):
-        """
-        :param source_path: The path of the source file
-        :type source_path: str
-        :return: whether the file's extention is *.java* or not
-        :rtype: bool
-        """
-        _, file_extension = os.path.splitext(source_path)
-        return file_extension == '.java'
-
-    @staticmethod
-    def get_file_extension(file_path):
-        """
-        :param file_path: The path of file
-        :type file_path: str
-        :return: file extension
-        :rtype: str
-        """
-        _, file_extension = os.path.splitext(file_path)
-        return file_extension
-
-    @staticmethod
-    def have_the_same_file_extension(file_path_1, file_path_2):
-        """
-        :param file_path_1: The path of file 1
-        :type file_path_1: str
-        :param file_path_2: The path of file 2
-        :type file_path_2: str
-        :return: same or not
-        :rtype: bool
-        """
-        return Program.get_file_extension(file_path_1) == Program.get_file_extension(file_path_2)
diff --git a/pyggi/test_result.py b/pyggi/test_result.py
index f609a36..7c264bf 100644
--- a/pyggi/test_result.py
+++ b/pyggi/test_result.py
@@ -67,7 +67,7 @@ class TestResult:
             , returns ``TestResult(True, {'runtime': 7, 'pass_all': 'true'})``
         """
         import re
-        matched = re.findall("\[PYGGI_RESULT\]\s*\{(.*?)\}\s", stdout)
+        matched = re.findall(r"\[PYGGI_RESULT\]\s*\{(.*?)\}\s", stdout)
         compiled = len(matched) != 0
         custom = None
         if compiled:
diff --git a/pyggi/xml/__init__.py b/pyggi/xml/__init__.py
new file mode 100644
index 0000000..0b08e12
--- /dev/null
+++ b/pyggi/xml/__init__.py
@@ -0,0 +1,3 @@
+from .program import Program
+from .atomic_operator import TagReplacement, TagDeletion, TagInsertion, TagMoving, TagSwap
+from .atomic_operator import XmlReplacement, XmlDeletion, XmlInsertion, XmlMoving, XmlSwap
diff --git a/pyggi/xml/atomic_operator.py b/pyggi/xml/atomic_operator.py
new file mode 100644
index 0000000..8b8d9d2
--- /dev/null
+++ b/pyggi/xml/atomic_operator.py
@@ -0,0 +1,423 @@
+import copy
+import random
+# import re
+from ..abstract import AbstractAtomicOperator
+from . import Program as XmlProgram
+
+class XmlAtomicOperator(AbstractAtomicOperator):
+    def __init__(self, target, ingredient=None):
+        self.target = target
+        self.ingredient = ingredient
+
+    @property
+    def modification_point(self):
+        return self.target
+
+    def is_valid_for(self, program):
+        return isinstance(program, XmlProgram)
+
+class XmlReplacement(XmlAtomicOperator):
+    def __str__(self):
+        return "XmlReplacement({}, {})".format(self.target, self.ingredient)
+
+    @classmethod
+    def create(cls, program, target_file=None, ingr_file=None, method='random'):
+        target_file = target_file or random.choice(program.target_files)
+        target = (target_file, program.select_modification_point(target_file, method))
+        ingr_file = ingr_file or random.choice(program.target_files)
+        ingredient = (ingr_file, program.select_modification_point(ingr_file, method))
+        return cls(target, ingredient)
+
+    def apply(self, program, new_contents, modification_points):
+        target_data = new_contents[self.target[0]]
+        target_pos = modification_points[self.target[0]][self.target[1]]
+        target_element = target_data.find(target_pos)
+        ingredient_data = new_contents[self.ingredient[0]]
+        ingredient_pos = modification_points[self.ingredient[0]][self.ingredient[1]]
+        ingredient_element = ingredient_data.find(ingredient_pos)
+        # replace xml
+        result = self.do_replace(target_element, ingredient_element)
+        if not result:
+            return False
+        # update modification points
+        # ???
+        return True
+
+    @staticmethod
+    def do_replace(target_element, ingredient_element):
+        if None in [target_element, ingredient_element]:
+            return False
+        tmp = target_element.tail
+        target_element.clear() # to remove children
+        target_element.tag = ingredient_element.tag
+        target_element.attrib = ingredient_element.attrib
+        target_element.text = ingredient_element.text
+        target_element.tail = tmp
+        for child in ingredient_element:
+            target_element.append(copy.deepcopy(child))
+        return True
+
+class TagReplacement(XmlReplacement):
+    def __str__(self):
+        return "TagReplacement({}, {})".format(self.target, self.ingredient)
+
+    @staticmethod
+    def do_replace(target_element, ingredient_element):
+        if None in [target_element, ingredient_element]:
+            return False
+        target_element.tag = ingredient_element.tag
+        target_element.attrib = ingredient_element.attrib
+        target_element.text = ingredient_element.text
+        if len(target_element) > 0:
+            *_, last_subchild = target_element
+            if len(ingredient_element) > 0:
+                *_, last_subchild2 = ingredient_element
+                last_subchild.tail = last_subchild2.tail
+            else:
+                last_subchild.tail = None
+        return True
+
+class XmlDeletion(XmlAtomicOperator):
+    def __str__(self):
+        return "XmlDeletion({})".format(self.target)
+
+    @classmethod
+    def create(cls, program, target_file=None, method='random'):
+        target_file = target_file or random.choice(program.target_files)
+        target = (target_file, program.select_modification_point(target_file, method))
+        return cls(target)
+
+    def apply(self, program, new_contents, modification_points):
+        target_data = new_contents[self.target[0]]
+        target_pos = modification_points[self.target[0]][self.target[1]]
+        target_element = target_data.find(target_pos)
+        parent_element = target_data.find(target_pos+'..')
+        # delete xml element
+        result = self.do_delete(parent_element, target_element)
+        if not result:
+            return False
+        # update modification points
+        # ???
+        return True
+
+    @staticmethod
+    def do_delete(parent_element, target_element):
+        if None in [parent_element, target_element]:
+            return False
+        if target_element.tail:
+            last_child = None
+            for child in parent_element:
+                if child == target_element:
+                    if last_child is not None:
+                        if last_child.tail:
+                            last_child.tail += target_element.tail
+                        else:
+                            last_child.tail = target_element.tail
+                    else:
+                        if parent_element.text:
+                            parent_element.text += target_element.tail
+                        else:
+                            parent_element.text = target_element.tail
+                    break
+                else:
+                    last_child = child
+        parent_element.remove(target_element)
+        return True
+
+class TagDeletion(XmlDeletion):
+    def __str__(self):
+        return "TagDeletion({})".format(self.target)
+
+    @staticmethod
+    def do_delete(parent_element, target_element):
+        if None in [parent_element, target_element]:
+            return False
+        if not target_element in parent_element:
+            print("------")
+            print(XmlProgram.tree_to_string(parent_element))
+            print("------")
+            print(XmlProgram.tree_to_string(target_element))
+            print("------")
+        if len(target_element) > 0:
+            *_, last_subchild = target_element
+            last_subchild.tail = target_element.tail
+            target_element.tail = None
+        last_child = None
+        pos = 0
+        for child in parent_element:
+            if child == target_element:
+                if len(target_element) > 0:
+                    for subchild in target_element:
+                        parent_element.insert(pos, copy.deepcopy(subchild))
+                        pos += 1
+                if target_element.tail:
+                    if last_child is not None:
+                        if last_child.tail:
+                            last_child.tail += target_element.tail
+                        else:
+                            last_child.tail = target_element.tail
+                    else:
+                        if parent_element.text:
+                            parent_element.text += target_element.tail
+                        else:
+                            parent_element.text = target_element.tail
+                break
+            else:
+                last_child = child
+                pos += 1
+        parent_element.remove(target_element)
+        return True
+
+class XmlInsertion(XmlAtomicOperator):
+    def __init__(self, target, ingredient, mode):
+        self.target = target
+        self.ingredient = ingredient
+        self.mode = mode
+
+    def __str__(self):
+        return "XmlInsertion({}, {})".format(self.target, self.ingredient)
+
+    @classmethod
+    def create(cls, program, target_file=None, ingr_file=None, method='random'):
+        target_file = target_file or random.choice(program.target_files)
+        target = (target_file, program.select_modification_point(target_file, method))
+        ingr_file = ingr_file or random.choice(program.target_files)
+        ingredient = (ingr_file, program.select_modification_point(ingr_file, method))
+        mode = 'inside' if (random.random() < 0.5) else 'after'
+        return cls(target, ingredient, mode)
+
+    def apply(self, program, new_contents, modification_points):
+        target_data = new_contents[self.target[0]]
+        target_pos = modification_points[self.target[0]][self.target[1]]
+        parent, tag, pos = XmlProgram.xpath_split(target_pos)
+        if self.mode == 'after':
+            target_element = target_data.find(target_pos)
+            parent_element = target_data.find(parent)
+        else:
+            target_element = None
+            parent_element = target_data.find(target_pos)
+        ingredient_data = new_contents[self.ingredient[0]]
+        ingredient_pos = modification_points[self.ingredient[0]][self.ingredient[1]]
+        ingredient_element = ingredient_data.find(ingredient_pos)
+        # insert xml
+        result = self.do_insert(parent_element, target_element, ingredient_element)
+        if not result:
+            return False
+        # update modification points
+        # ???
+        return True
+
+    @staticmethod
+    def do_insert(parent_element, target_element, ingredient_element):
+        if None in [parent_element, ingredient_element]:
+            return False
+        if target_element is not None:
+            true_pos = 0
+            last_child = None
+            for child in parent_element:
+                true_pos += 1
+                if child == target_element:
+                    break
+                else:
+                    last_child = child
+            else:
+                return False
+            element = copy.deepcopy(ingredient_element)
+            element.tail = target_element.tail
+            target_element.tail = None
+            parent_element.insert(true_pos, element)
+        else:
+            element = copy.deepcopy(ingredient_element)
+            element.tail = None
+            parent_element.insert(0, element)
+        return True
+
+class TagInsertion(XmlAtomicOperator):
+    def __str__(self):
+        return "TagInsertion({}, {})".format(self.target, self.ingredient)
+
+    @classmethod
+    def create(cls, program, target_file=None, ingr_file=None, method='random'):
+        target_file = target_file or random.choice(program.target_files)
+        target = (target_file, program.select_modification_point(target_file, method))
+        ingr_file = ingr_file or random.choice(program.target_files)
+        ingredient = (ingr_file, program.select_modification_point(ingr_file, method))
+        return cls(target, ingredient)
+
+    def apply(self, program, new_contents, modification_points):
+        target_data = new_contents[self.target[0]]
+        target_pos = modification_points[self.target[0]][self.target[1]]
+        parent = XmlProgram.xpath_parent(target_pos)
+        target_element = target_data.find(target_pos)
+        parent_element = target_data.find(parent)
+        ingredient_data = new_contents[self.ingredient[0]]
+        ingredient_pos = modification_points[self.ingredient[0]][self.ingredient[1]]
+        ingredient_element = ingredient_data.find(ingredient_pos)
+        # insert xml
+        result = self.do_insert(parent_element, target_element, ingredient_element)
+        if not result:
+            return False
+        # update modification points
+        # ???
+        return True
+
+    @staticmethod
+    def do_insert(parent_element, target_element, ingredient_element):
+        if None in [parent_element, target_element, ingredient_element]:
+            return False
+        if not target_element in parent_element:
+            return False
+        element = copy.deepcopy(ingredient_element)
+        element.tail = target_element.tail
+        for child in reversed(element):
+            element.remove(child)
+        element.insert(0, target_element)
+        if len(ingredient_element) > 0:
+            *_, last_child = ingredient_element
+            target_element.tail = last_child.tail
+        else:
+            target_element.tail = None
+        for pos, child in enumerate(parent_element):
+            if child == target_element:
+                parent_element.remove(child)
+                parent_element.insert(pos, element)
+                return True
+        else:
+            assert False
+
+class XmlMoving(XmlAtomicOperator):
+    def __init__(self, target, ingredient, mode):
+        self.target = target
+        self.ingredient = ingredient
+        self.mode = mode
+
+    def __str__(self):
+        return "XmlMoving({}, {})".format(self.target, self.ingredient)
+
+    @classmethod
+    def create(cls, program, target_file=None, method='random'):
+        target_file = target_file or random.choice(program.target_files)
+        target = (target_file, program.select_modification_point(target_file, method))
+        ingredient = (target_file, program.select_modification_point(target_file, method))
+        mode = 'inside' if (random.random() < 0.5) else 'after'
+        return cls(target, ingredient, mode)
+
+    def apply(self, program, new_contents, modification_points):
+        target_data = new_contents[self.target[0]]
+        target_pos = modification_points[self.target[0]][self.target[1]]
+        parent_target = XmlProgram.xpath_parent(target_pos)
+        if self.mode == 'after':
+            target_element = target_data.find(target_pos)
+            parent_target_element = target_data.find(parent_target)
+        else:
+            target_element = None
+            parent_target_element = target_data.find(target_pos)
+        ingredient_pos = modification_points[self.target[0]][self.ingredient[1]]
+        parent_ingredient = XmlProgram.xpath_parent(ingredient_pos)
+        ingredient_element = target_data.find(ingredient_pos)
+        parent_ingredient_element = target_data.find(parent_ingredient)
+        # insert xml
+        result = self.do_move(parent_target_element, target_element, parent_ingredient_element, ingredient_element)
+        if not result:
+            return False
+        # update modification points
+        # ???
+        return True
+
+    @staticmethod
+    def do_move(parent_target_element, target_element, parent_ingredient_element, ingredient_element):
+        result = XmlInsertion.do_insert(parent_target_element, target_element, ingredient_element)
+        if not result:
+            return False
+        result = XmlDeletion.do_delete(parent_ingredient_element, ingredient_element)
+        assert result
+        return True
+
+class TagMoving(XmlAtomicOperator):
+    def __str__(self):
+        return "TagMoving({}, {})".format(self.target, self.ingredient)
+
+    @classmethod
+    def create(cls, program, target_file=None, method='random'):
+        target_file = target_file or random.choice(program.target_files)
+        target = (target_file, program.select_modification_point(target_file, method))
+        ingredient = (target_file, program.select_modification_point(target_file, method))
+        return cls(target, ingredient)
+
+    def apply(self, program, new_contents, modification_points):
+        target_data = new_contents[self.target[0]]
+        target_pos = modification_points[self.target[0]][self.target[1]]
+        parent_target = XmlProgram.xpath_parent(target_pos)
+        target_element = target_data.find(target_pos)
+        parent_target_element = target_data.find(parent_target)
+        ingredient_pos = modification_points[self.target[0]][self.ingredient[1]]
+        parent_ingredient = XmlProgram.xpath_parent(ingredient_pos)
+        ingredient_element = target_data.find(ingredient_pos)
+        parent_ingredient_element = target_data.find(parent_ingredient)
+        # insert xml
+        result = self.do_move(parent_target_element, target_element, parent_ingredient_element, ingredient_element)
+        if not result:
+            return False
+        # update modification points
+        # ???
+        return True
+
+    @staticmethod
+    def do_move(parent_target_element, target_element, parent_ingredient_element, ingredient_element):
+        if target_element == ingredient_element:
+            return True
+        result = TagInsertion.do_insert(parent_target_element, target_element, ingredient_element)
+        if not result:
+            return False
+        result = TagDeletion.do_delete(parent_ingredient_element, ingredient_element)
+        assert result
+        return True
+
+class XmlSwap(XmlAtomicOperator):
+    def __str__(self):
+        return "XmlSwap({}, {})".format(self.target, self.ingredient)
+
+    @classmethod
+    def create(cls, program, target_file=None, method='random'):
+        target_file = target_file or random.choice(program.target_files)
+        target = (target_file, program.select_modification_point(target_file, method))
+        ingredient = (target_file, program.select_modification_point(target_file, method))
+        return cls(target, ingredient)
+
+    def apply(self, program, new_contents, modification_points):
+        target_data = new_contents[self.target[0]]
+        target_pos = modification_points[self.target[0]][self.target[1]]
+        target_element = target_data.find(target_pos)
+        ingredient_pos = modification_points[self.target[0]][self.ingredient[1]]
+        ingredient_element = target_data.find(ingredient_pos)
+        # swap
+        result = self.do_swap(target_element, ingredient_element)
+        if not result:
+            return False
+        # update modification points
+        # ???
+        return True
+
+    @staticmethod
+    def do_swap(target_element, ingredient_element):
+        tmp_element = copy.deepcopy(target_element)
+        result = XmlReplacement.do_replace(target_element, ingredient_element)
+        if not result:
+            return False
+        result = XmlReplacement.do_replace(ingredient_element, tmp_element)
+        assert result
+        return True
+
+class TagSwap(XmlSwap):
+    def __str__(self):
+        return "TagSwap({}, {})".format(self.target, self.ingredient)
+
+    @staticmethod
+    def do_swap(target_element, ingredient_element):
+        tmp_element = copy.deepcopy(target_element)
+        result = TagReplacement.do_replace(target_element, ingredient_element)
+        if not result:
+            return False
+        result = TagReplacement.do_replace(ingredient_element, tmp_element)
+        assert result
+        return True
diff --git a/pyggi/xml/program.py b/pyggi/xml/program.py
new file mode 100644
index 0000000..417aabb
--- /dev/null
+++ b/pyggi/xml/program.py
@@ -0,0 +1,102 @@
+import os
+import re
+from xml.etree import ElementTree
+from ..abstract import AbstractProgram
+
+class Program(AbstractProgram):
+    @property
+    def modification_points(self):
+        """
+        :return: The list of position of modification points for each target program
+        :rtype: dict(str, ?)
+        """
+        if self._modification_points:
+            return self._modification_points
+
+        def aux(accu, prefix, root):
+            tags = dict()
+            for child in root:
+                if child.tag in tags:
+                    tags[child.tag] += 1
+                else:
+                    tags[child.tag] = 1
+                s = '{}/{}[{}]'.format(prefix, child.tag, tags[child.tag])
+                accu.append(s)
+                accu = aux(accu, s, child)
+            return accu
+
+        self._modification_points = dict()
+        for target_file in self.target_files:
+            tree = self.contents[target_file]
+            points = aux([], '.', tree)
+            self._modification_points[target_file] = points
+        return self._modification_points
+
+    def print_modification_points(self, target_file, indices=None):
+        title_format = "=" * 25 + " {}: {} {} " + "=" * 25
+        contents = self.contents[target_file]
+        points = self.modification_points[target_file]
+        if not indices:
+            indices = range(len(points))
+        for i in indices:
+            print(title_format.format(target_file, 'xpath', i, points[i]))
+            print(points[i])
+            print(self.to_source(contents.find(points[i])).rstrip())
+            print()
+
+    def to_source(self, contents_of_file):
+        return Program.tree_to_string(contents_of_file)
+
+    @staticmethod
+    def strip_xml_from_tree(tree):
+        return ''.join(tree.itertext())
+
+    @staticmethod
+    def strip_xml_from_string(content):
+        tree = ElementTree.fromstring(content)
+        return Program.strip_xml_from_tree(tree)
+
+    def parse(self, path, target_files):
+        contents = {}
+        for target in target_files:
+            with open(os.path.join(path, target)) as f:
+                contents[target] = Program.string_to_tree(f.read())
+        return contents
+
+    @staticmethod
+    def string_to_tree(s):
+        xml = re.sub(r'\s+xmlns="[^"]+"', '', s, count=1)
+        try:
+            return ElementTree.fromstring(xml)
+        except ElementTree.ParseError as e:
+            raise Exception('Program', 'ParseError: ({}) {}'.format(target, str(e))) from None
+
+    @staticmethod
+    def tree_to_string(tree):
+        return ElementTree.tostring(tree, encoding='unicode', method='xml')
+
+    @staticmethod
+    def xpath_to_tag(xpath):
+        if xpath == '.':
+            return '.'
+        pattern = re.compile(r'^(.*)/([^\[]+)(?:\[([^\]]+)\])?$')
+        match = re.match(pattern, xpath)
+        assert match
+        return match.group(2)
+
+    @staticmethod
+    def xpath_parent(xpath):
+        if xpath == '.':
+            return '.'
+        pattern = re.compile(r'^(.*)/([^\[]+)(?:\[([^\]]+)\])?$')
+        match = re.match(pattern, xpath)
+        assert match
+        return match.group(1)
+
+    @staticmethod
+    def xpath_split(xpath):
+        assert xpath != '.'
+        pattern = re.compile(r'^(.*)/([^\[]+)(?:\[([^\]]+)\])?$')
+        match = re.match(pattern, xpath)
+        assert match
+        return (match.group(1), match.group(2), int(match.group(3)))
diff --git a/sample/dummy/opti/PYGGI_CONFIG b/sample/dummy/opti/PYGGI_CONFIG
new file mode 100644
index 0000000..c07d16a
--- /dev/null
+++ b/sample/dummy/opti/PYGGI_CONFIG
@@ -0,0 +1,7 @@
+{
+  "target_files": [
+    "dummy1",
+    "dummy2"
+  ],
+  "test_command": "ruby run.rb"
+}
diff --git a/sample/dummy/opti/dummy1 b/sample/dummy/opti/dummy1
new file mode 100644
index 0000000..90cbab6
--- /dev/null
+++ b/sample/dummy/opti/dummy1
@@ -0,0 +1,20 @@
+-67
+-64
+-24
+23
+-54
+82
+26
+5
+20
+-94
+78
+16
+72
+-99
+-56
+3
+-23
+75
+51
+65
diff --git a/sample/dummy/opti/dummy2 b/sample/dummy/opti/dummy2
new file mode 100644
index 0000000..d9e8c05
--- /dev/null
+++ b/sample/dummy/opti/dummy2
@@ -0,0 +1,21 @@
+50
+54
+9
+23
+58
+5
+84
+20
+41
+39
+52
+49
+45
+29
+28
+82
+97
+80
+30
+33
+
diff --git a/sample/dummy/opti/run.rb b/sample/dummy/opti/run.rb
new file mode 100644
index 0000000..ff35c7c
--- /dev/null
+++ b/sample/dummy/opti/run.rb
@@ -0,0 +1,26 @@
+#!/bin/ruby
+
+# read both files
+d1 = File.readlines('./dummy1').map(&:chomp).reject(&:empty?).map(&:to_i)
+d2 = File.readlines('./dummy2').map(&:chomp).reject(&:empty?).map(&:to_i)
+
+# compile
+# ok!
+
+# test
+t1 = d1.uniq.size == d1.size
+t2 = d2.uniq.size == d2.size
+test = t1 && t2
+
+# compute
+a1 = d1.map(&:abs)
+a2 = d2.each_cons(3).map {|x,y,z| [x<y, y<z, x<z].count(false)}
+
+# fitness
+r1 = 2*a1.inject(0,&:+)/a1.size + (a1.size - 20).abs**2
+r2 = 2*a2.inject(0,&:+) + (a2.size - 20).abs**2
+run = r1 + r2
+
+if rand > 0.05
+  puts '[PYGGI_RESULT] { runtime: %d, pass_all: %s, a1: %s, a2: %s, t1: %s, t2: %s, r1: %d, r2: %d}'%[r1+r2, test, a1.map(&:to_s)*'|', a2.map(&:to_s)*'|', t1, t2, r1, r2]
+end
diff --git a/sample/dummy/opti/run.sh b/sample/dummy/opti/run.sh
new file mode 100755
index 0000000..1ba8f0b
--- /dev/null
+++ b/sample/dummy/opti/run.sh
@@ -0,0 +1,3 @@
+#!/bin/sh
+
+echo '[PYGGI_RESULT] { runtime: 0, pass_all: true}'
diff --git a/sample/dummy/python/PYGGI_CONFIG b/sample/dummy/python/PYGGI_CONFIG
new file mode 100644
index 0000000..21900ab
--- /dev/null
+++ b/sample/dummy/python/PYGGI_CONFIG
@@ -0,0 +1,6 @@
+{
+  "target_files": [
+    "triangle.py"
+  ],
+  "test_command": "./run.rb"
+}
diff --git a/sample/dummy/python/run.rb b/sample/dummy/python/run.rb
new file mode 100755
index 0000000..46ef776
--- /dev/null
+++ b/sample/dummy/python/run.rb
@@ -0,0 +1,10 @@
+#!/bin/ruby
+
+output = `pytest -s test_triangle.py`
+File.write('fuck', output)
+
+pass = output.match(/error|failed/).nil?
+runtime = output[/runtime: (.*)/] ? $1 : 999
+puts '[PYGGI_RESULT] { pass_all: %s, runtime: %s}'%[pass, runtime]
+
+
diff --git a/sample/dummy/python/test_triangle.py b/sample/dummy/python/test_triangle.py
new file mode 100644
index 0000000..b610770
--- /dev/null
+++ b/sample/dummy/python/test_triangle.py
@@ -0,0 +1,40 @@
+import time
+import pytest
+from triangle import TriangleType, classify_triangle
+
+
+def check_classification(triangles, expected_result):
+    for triangle in triangles:
+        assert classify_triangle(*triangle) == expected_result
+
+
+def test_invalid_triangles():
+    triangles = [(1, 2, 9), (1, 9, 2), (2, 1, 9), (2, 9, 1), (9, 1, 2),
+                 (9, 2, 1), (1, 1, -1), (1, -1, 1), (-1, 1, 1)]
+    check_classification(triangles, TriangleType.INVALID)
+
+
+def test_equalateral_triangles():
+    triangles = [(1, 1, 1), (100, 100, 100), (99, 99, 99)]
+    check_classification(triangles, TriangleType.EQUALATERAL)
+
+
+def test_isoceles_triangles():
+    triangles = [(100, 90, 90), (90, 100, 90), (90, 90, 100), (2, 2, 3)]
+
+    check_classification(triangles, TriangleType.ISOCELES)
+
+
+def test_scalene_triangles():
+    triangles = [(5, 4, 3), (5, 3, 4), (4, 5, 3), (4, 3, 5), (3, 5, 4)]
+    check_classification(triangles, TriangleType.SCALENE)
+
+
+@pytest.fixture(scope="session", autouse=True)
+def starter(request):
+    start_time = time.time()
+
+    def finalizer():
+        print("runtime: {}".format(str(time.time() - start_time)))
+
+    request.addfinalizer(finalizer)
diff --git a/sample/dummy/python/triangle.py b/sample/dummy/python/triangle.py
new file mode 100644
index 0000000..b5bfee3
--- /dev/null
+++ b/sample/dummy/python/triangle.py
@@ -0,0 +1,40 @@
+import time
+from enum import Enum
+
+
+class TriangleType(Enum):
+    INVALID, EQUALATERAL, ISOCELES, SCALENE = 0, 1, 2, 3
+
+
+def delay():
+    time.sleep(0.01)
+
+
+def classify_triangle(a, b, c):
+
+    delay()
+
+    # Sort the sides so that a <= b <= c
+    if a > b:
+        tmp = a
+        a = b
+        b = tmp
+
+    if a > c:
+        tmp = a
+        a = c
+        c = tmp
+
+    if b > c:
+        tmp = b
+        b = c
+        c = tmp
+
+    if a + b <= c:
+        return TriangleType.INVALID
+    elif a == b and b == c:
+        return TriangleType.EQUALATERAL
+    elif a == b or b == c:
+        return TriangleType.ISOCELES
+    else:
+        return TriangleType.SCALENE
diff --git a/sample/dummy/xml/PYGGI_CONFIG b/sample/dummy/xml/PYGGI_CONFIG
new file mode 100644
index 0000000..b867ee1
--- /dev/null
+++ b/sample/dummy/xml/PYGGI_CONFIG
@@ -0,0 +1,6 @@
+{
+  "target_files": [
+    "dummy.xml"
+  ],
+  "test_command": "ruby run.rb"
+}
diff --git a/sample/dummy/xml/dummy.xml b/sample/dummy/xml/dummy.xml
new file mode 100644
index 0000000..39d0dc6
--- /dev/null
+++ b/sample/dummy/xml/dummy.xml
@@ -0,0 +1,15 @@
+<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
+<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="0.9.5" language="C" filename="tmp.c"><comment type="line">// Example</comment>
+<function><type><name>void</name></type> <name>main</name><parameter_list>()</parameter_list> <block>{
+  <decl_stmt><decl><type><name>int</name></type> <name>x</name></decl>, <decl><type ref="prev"/><name>y</name></decl>;</decl_stmt>
+  <expr_stmt><expr><name>x</name> <operator>=</operator> <call><name>f</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
+  <if>if <condition>(<expr><name>x</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
+    <if>if <condition>(<expr><name>x</name> <operator>&lt;</operator> <literal type="number">10</literal></expr>)</condition><then>
+      <block type="pseudo"><expr_stmt><expr><name>y</name> <operator>=</operator> <name>x</name></expr>;</expr_stmt></block></then>
+    <else>else
+      <block type="pseudo"><expr_stmt><expr><name>y</name> <operator>=</operator> <literal type="number">2</literal><operator>*</operator><name>x</name></expr>;</expr_stmt></block></else></if>
+  }</block></then> <else>else <block>{
+    <expr_stmt><expr><name>y</name> <operator>=</operator> <call><name>g</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
+  }</block></else></if>
+}</block></function>
+</unit>
diff --git a/sample/dummy/xml/run.rb b/sample/dummy/xml/run.rb
new file mode 100644
index 0000000..92193c9
--- /dev/null
+++ b/sample/dummy/xml/run.rb
@@ -0,0 +1,29 @@
+#!/bin/ruby
+# require 'nokogiri'
+
+# # strip xml
+# xml = File.open("./dummy.xml") { |f| Nokogiri::XML(f) }
+# xml.remove_namespaces!
+# out = xml.text
+# out[0] = '' if out[0] == "\n"
+
+# # read file
+# d1 = out.split("\n").map(&:chomp).reject(&:empty?).map(&:to_i)
+
+# # compile
+# # ok!
+
+# # test
+# test = d1.uniq.size == d1.size
+
+# # compute
+# a1 = d1.map(&:abs)
+
+# # fitness
+# run = 2*a1.inject(0,&:+)/a1.size + (a1.size - 20).abs**2
+
+# if rand > 0.05
+#   puts '[PYGGI_RESULT] { runtime: %d, pass_all: %s, a1: %s, a2: %s, t1: %s, t2: %s, r1: %d, r2: %d}'%[run, test, a1.map(&:to_s)*'|']
+# end
+
+puts '[PYGGI_RESULT] { runtime: %d, pass_all: %s}'%[rand*100, rand > 0.01]
diff --git a/sample/dummy/xml/run.sh b/sample/dummy/xml/run.sh
new file mode 100755
index 0000000..1ba8f0b
--- /dev/null
+++ b/sample/dummy/xml/run.sh
@@ -0,0 +1,3 @@
+#!/bin/sh
+
+echo '[PYGGI_RESULT] { runtime: 0, pass_all: true}'
diff --git a/setup.py b/setup.py
index 9e0b8e6..79f8664 100644
--- a/setup.py
+++ b/setup.py
@@ -16,6 +16,7 @@ setup(
     author_email='',
     license='MIT',
     packages=find_packages(),
-    install_requires=['argparse', 'astor'],
+    install_requires=['argparse'],
+    extra_requires=['astor', 'pytest'],
     dependency_links=[],
     zip_safe=False)
diff --git a/test/resource/xml/PYGGI_CONFIG b/test/resource/xml/PYGGI_CONFIG
new file mode 100644
index 0000000..b867ee1
--- /dev/null
+++ b/test/resource/xml/PYGGI_CONFIG
@@ -0,0 +1,6 @@
+{
+  "target_files": [
+    "dummy.xml"
+  ],
+  "test_command": "ruby run.rb"
+}
diff --git a/test/resource/xml/dummy.xml b/test/resource/xml/dummy.xml
new file mode 100644
index 0000000..39d0dc6
--- /dev/null
+++ b/test/resource/xml/dummy.xml
@@ -0,0 +1,15 @@
+<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
+<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="0.9.5" language="C" filename="tmp.c"><comment type="line">// Example</comment>
+<function><type><name>void</name></type> <name>main</name><parameter_list>()</parameter_list> <block>{
+  <decl_stmt><decl><type><name>int</name></type> <name>x</name></decl>, <decl><type ref="prev"/><name>y</name></decl>;</decl_stmt>
+  <expr_stmt><expr><name>x</name> <operator>=</operator> <call><name>f</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
+  <if>if <condition>(<expr><name>x</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><then> <block>{
+    <if>if <condition>(<expr><name>x</name> <operator>&lt;</operator> <literal type="number">10</literal></expr>)</condition><then>
+      <block type="pseudo"><expr_stmt><expr><name>y</name> <operator>=</operator> <name>x</name></expr>;</expr_stmt></block></then>
+    <else>else
+      <block type="pseudo"><expr_stmt><expr><name>y</name> <operator>=</operator> <literal type="number">2</literal><operator>*</operator><name>x</name></expr>;</expr_stmt></block></else></if>
+  }</block></then> <else>else <block>{
+    <expr_stmt><expr><name>y</name> <operator>=</operator> <call><name>g</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
+  }</block></else></if>
+}</block></function>
+</unit>
diff --git a/test/resource/xml/run.rb b/test/resource/xml/run.rb
new file mode 100644
index 0000000..92193c9
--- /dev/null
+++ b/test/resource/xml/run.rb
@@ -0,0 +1,29 @@
+#!/bin/ruby
+# require 'nokogiri'
+
+# # strip xml
+# xml = File.open("./dummy.xml") { |f| Nokogiri::XML(f) }
+# xml.remove_namespaces!
+# out = xml.text
+# out[0] = '' if out[0] == "\n"
+
+# # read file
+# d1 = out.split("\n").map(&:chomp).reject(&:empty?).map(&:to_i)
+
+# # compile
+# # ok!
+
+# # test
+# test = d1.uniq.size == d1.size
+
+# # compute
+# a1 = d1.map(&:abs)
+
+# # fitness
+# run = 2*a1.inject(0,&:+)/a1.size + (a1.size - 20).abs**2
+
+# if rand > 0.05
+#   puts '[PYGGI_RESULT] { runtime: %d, pass_all: %s, a1: %s, a2: %s, t1: %s, t2: %s, r1: %d, r2: %d}'%[run, test, a1.map(&:to_s)*'|']
+# end
+
+puts '[PYGGI_RESULT] { runtime: %d, pass_all: %s}'%[rand*100, rand > 0.01]
diff --git a/test/resource/xml/run.sh b/test/resource/xml/run.sh
new file mode 100755
index 0000000..1ba8f0b
--- /dev/null
+++ b/test/resource/xml/run.sh
@@ -0,0 +1,3 @@
+#!/bin/sh
+
+echo '[PYGGI_RESULT] { runtime: 0, pass_all: true}'
diff --git a/test/test_atomic_operator.py b/test/test_atomic_operator.py
index 8030498..f49cae1 100644
--- a/test/test_atomic_operator.py
+++ b/test/test_atomic_operator.py
@@ -1,6 +1,6 @@
 import pytest
-from pyggi import Program, GranularityLevel
-from pyggi.atomic_operator import LineReplacement, LineInsertion
+from pyggi.line import Program as LineProgram
+from pyggi.line import LineReplacement, LineInsertion
 
 
 @pytest.fixture(scope='session')
@@ -32,8 +32,7 @@ class TestAtomicOperator(object):
             assert line_replacement.ingredient == ingredient
 
         def test_create(self):
-            program = Program('./resource/Triangle_bug',
-                              GranularityLevel.LINE)
+            program = LineProgram('./resource/Triangle_bug')
             random_line_deletion_0 = LineReplacement.create(
                 program,
                 line_file='Triangle.java',
@@ -59,8 +58,7 @@ class TestAtomicOperator(object):
             assert line_insertion.ingredient == ingredient
 
         def test_create(self):
-            program = Program('./resource/Triangle_bug',
-                              GranularityLevel.LINE)
+            program = LineProgram('./resource/Triangle_bug')
             random_line_insertion = LineInsertion.create(
                 program, line_file='Triangle.java', ingr_file='Triangle.java')
 
diff --git a/test/test_custom_operator.py b/test/test_custom_operator.py
index 9811156..3efb9bb 100644
--- a/test/test_custom_operator.py
+++ b/test/test_custom_operator.py
@@ -1,7 +1,6 @@
 import pytest
-from pyggi import Program, GranularityLevel
-from pyggi.custom_operator import LineDeletion, LineMoving
-from pyggi.atomic_operator import LineReplacement, LineInsertion
+from pyggi.line import Program as LineProgram
+from pyggi.line import LineReplacement, LineInsertion, LineDeletion, LineMoving
 
 
 @pytest.fixture(scope='session')
@@ -41,8 +40,7 @@ class TestCustomOperator(object):
                                     None)] == line_deletion.atomic_operators
 
         def test_create(self):
-            program = Program('./resource/Triangle_bug',
-                              GranularityLevel.LINE)
+            program = LineProgram('./resource/Triangle_bug')
             random_line_deletion = LineDeletion.create(program)
 
             assert random_line_deletion.x is not None
@@ -73,8 +71,7 @@ class TestCustomOperator(object):
             ] == line_moving.atomic_operators
 
         def test_create(self):
-            program = Program('./resource/Triangle_bug',
-                              GranularityLevel.LINE)
+            program = LineProgram('./resource/Triangle_bug')
             random_line_moving = LineMoving.create(program)
 
             assert random_line_moving.x is not None
diff --git a/test/test_patch.py b/test/test_patch.py
index b8f60ac..a6cb235 100644
--- a/test/test_patch.py
+++ b/test/test_patch.py
@@ -1,11 +1,12 @@
 import pytest
-from pyggi import Program, Patch, GranularityLevel
-from pyggi.custom_operator import LineDeletion, LineMoving
+from pyggi.line import Program as LineProgram
+from pyggi.line import LineDeletion, LineMoving
+from pyggi import Patch
 
 
 @pytest.fixture(scope='session')
 def setup():
-    program = Program('./resource/Triangle_bug', GranularityLevel.LINE)
+    program = LineProgram('./resource/Triangle_bug')
     assert len(program.target_files) == 1
     assert program.target_files[0] == 'Triangle.java'
 
@@ -34,7 +35,7 @@ class TestPatch(object):
 
     def test_eq(self, setup):
         patch, program = setup
-        program2 = Program('./resource/Triangle_bug', GranularityLevel.LINE)
+        program2 = LineProgram('./resource/Triangle_bug')
         patch2 = Patch(program2)
 
         assert patch == patch2
diff --git a/test/test_program.py b/test/test_program.py
index a59e43e..6bd899d 100644
--- a/test/test_program.py
+++ b/test/test_program.py
@@ -1,24 +1,18 @@
 import pytest
 import os
-from pyggi import Program, GranularityLevel
+from pyggi.abstract import AbstractProgram
+from pyggi.line import Program as LineProgram
 
 
 @pytest.fixture(scope='session')
 def setup():
-    program = Program('./resource/Triangle_bug', GranularityLevel.LINE)
+    program = LineProgram('./resource/Triangle_bug')
     assert len(program.target_files) == 1
     assert program.target_files[0] == 'Triangle.java'
 
     return program
 
 
-class TestGranularityLevel(object):
-
-    def test_is_valid(self):
-        assert GranularityLevel.is_valid('line')
-        assert not GranularityLevel.is_valid('random_text')
-
-
 class TestProgram(object):
 
     def test_init(self, setup):
@@ -26,25 +20,23 @@ class TestProgram(object):
 
         assert not program.path.endswith('/')
         assert program.name == os.path.basename(program.path)
-        assert program.granularity_level == GranularityLevel.LINE
         assert program.test_command is not None
         assert program.target_files is not None
 
     def test_tmp_path(self, setup):
         program = setup
 
-        assert program.tmp_path == os.path.join(Program.TMP_DIR, program.name)
+        assert program.tmp_path == os.path.join(AbstractProgram.TMP_DIR, program.name)
 
     def test_clean_tmp_dir(self, setup):
         program = setup
         os.mkdir(os.path.join(program.tmp_path, 'test_dir'))
-        Program.clean_tmp_dir(program.tmp_path)
+        AbstractProgram.clean_tmp_dir(program.tmp_path)
 
         assert not os.listdir(program.tmp_path)
 
     def test_parse(self, setup):
         program = setup
-        contents = Program.parse(program.granularity_level, program.path,
-                                 program.target_files)
+        contents = program.parse(program.path, program.target_files)
         assert 'Triangle.java' in contents
         assert len(contents['Triangle.java']) > 0
diff --git a/test/test_xml.py b/test/test_xml.py
new file mode 100644
index 0000000..db74048
--- /dev/null
+++ b/test/test_xml.py
@@ -0,0 +1,770 @@
+import pytest
+import os
+from copy import deepcopy
+from pyggi.xml import Program as XmlProgram
+from pyggi.xml import TagReplacement, TagDeletion, TagInsertion, TagMoving, TagSwap
+from pyggi.xml import XmlReplacement, XmlDeletion, XmlInsertion, XmlMoving, XmlSwap
+
+
+@pytest.fixture(scope='session')
+def setup():
+    program = XmlProgram('./resource/xml')
+    return program
+
+
+class TestProgram(object):
+
+    def test_strip_xml(self, setup):
+        program = setup
+        out = """// Example
+void main() {
+  int x, y;
+  x = f(x);
+  if (x > 0) {
+    if (x < 10)
+      y = x;
+    else
+      y = 2*x;
+  } else {
+    y = g(x);
+  }
+}
+"""
+
+        assert XmlProgram.strip_xml_from_tree(program.contents['dummy.xml']) == out
+
+    def test_modification_points(self, setup):
+        program = setup
+        points = program.modification_points
+        xpath = './function[1]/block[1]/if[1]/then[1]/block[1]/if[1]/condition[1]'
+
+        assert len(points['dummy.xml']) == 67
+        assert xpath in points['dummy.xml']
+
+    def test_xpath(self, setup):
+        program = setup
+        xpath = './function[1]/block[1]/if[1]/then[1]/block[1]/if[1]/condition[1]'
+        parent =  './function[1]/block[1]/if[1]/then[1]/block[1]/if[1]'
+        tag = 'condition'
+
+        assert XmlProgram.xpath_to_tag(xpath) == tag
+        assert XmlProgram.xpath_to_tag('.') == '.'
+        assert XmlProgram.xpath_parent(xpath) == parent
+        assert XmlProgram.xpath_parent('.') == '.'
+        assert XmlProgram.xpath_split(xpath) == (parent, tag, 1)
+
+    def test_tag_replacement_0(self):
+        source = """<root>
+  c1
+  <a>a1</a>
+  c2
+  <a>a2</a>
+  c3
+</root>"""
+        out = """<root>
+  c1
+  <a>a2</a>
+  c2
+  <a>a2</a>
+  c3
+</root>"""
+        tree = XmlProgram.string_to_tree(source)
+        TagReplacement.do_replace(tree.find('./a[1]'), tree.find('./a[2]'))
+        assert XmlProgram.tree_to_string(tree) == out
+
+    def test_tag_replacement_1(self):
+        source = """<root>
+  c1
+  <a>a1<b>a1b</b>a1_</a>
+  c2
+  <a>a2<b>a2b</b>a2_</a>
+  c3
+</root>"""
+        out = """<root>
+  c1
+  <a>a2<b>a1b</b>a2_</a>
+  c2
+  <a>a2<b>a2b</b>a2_</a>
+  c3
+</root>"""
+        tree = XmlProgram.string_to_tree(source)
+        TagReplacement.do_replace(tree.find('./a[1]'), tree.find('./a[2]'))
+        assert XmlProgram.tree_to_string(tree) == out
+
+    def test_tag_replacement_2(self):
+        source = """<root>
+<if>if <cond>(ifcond)</cond> <block>{
+  ... if content ...
+}</block></if>
+<while>while <cond>(whilecond)</cond> <block>{
+  ... while content ...
+}</block></while>
+</root>"""
+        out = """<root>
+<while>while <cond>(ifcond)</cond> <block>{
+  ... if content ...
+}</block></while>
+<while>while <cond>(whilecond)</cond> <block>{
+  ... while content ...
+}</block></while>
+</root>"""
+        tree = XmlProgram.string_to_tree(source)
+        TagReplacement.do_replace(tree.find('./if[1]'), tree.find('./while[1]'))
+        assert XmlProgram.tree_to_string(tree) == out
+
+
+    def test_xml_replacement_0(self):
+        source = """<root>
+  c1
+  <a>a1</a>
+  c2
+  <a>a2</a>
+  c3
+</root>"""
+        out = """<root>
+  c1
+  <a>a2</a>
+  c2
+  <a>a2</a>
+  c3
+</root>"""
+        tree = XmlProgram.string_to_tree(source)
+        XmlReplacement.do_replace(tree.find('./a[1]'), tree.find('./a[2]'))
+        assert XmlProgram.tree_to_string(tree) == out
+
+    def test_xml_replacement_1(self):
+        source = """<root>
+  c1
+  <a>a1<b>a1b</b>a1_</a>
+  c2
+  <a>a2<b>a2b</b>a2_</a>
+  c3
+</root>"""
+        out = """<root>
+  c1
+  <a>a2<b>a2b</b>a2_</a>
+  c2
+  <a>a2<b>a2b</b>a2_</a>
+  c3
+</root>"""
+        tree = XmlProgram.string_to_tree(source)
+        XmlReplacement.do_replace(tree.find('./a[1]'), tree.find('./a[2]'))
+        assert XmlProgram.tree_to_string(tree) == out
+
+    def test_xml_replacement_2(self):
+        source = """<root>
+<if>if <cond>(ifcond)</cond> <block>{
+  ... if content ...
+}</block></if>
+<while>while <cond>(whilecond)</cond> <block>{
+  ... while content ...
+}</block></while>
+</root>"""
+        out = """<root>
+<while>while <cond>(whilecond)</cond> <block>{
+  ... while content ...
+}</block></while>
+<while>while <cond>(whilecond)</cond> <block>{
+  ... while content ...
+}</block></while>
+</root>"""
+        tree = XmlProgram.string_to_tree(source)
+        XmlReplacement.do_replace(tree.find('./if[1]'), tree.find('./while[1]'))
+        assert XmlProgram.tree_to_string(tree) == out
+
+    def test_tag_deletion_0(self):
+        source = """<root>
+  c1
+  <a>a1</a>
+  c2
+  <a>a2</a>
+  c3
+</root>"""
+        out = """<root>
+  c1
+  
+  c2
+  <a>a2</a>
+  c3
+</root>"""
+        tree = XmlProgram.string_to_tree(source)
+        TagDeletion.do_delete(tree.find('.'), tree.find('./a[1]'))
+        assert XmlProgram.tree_to_string(tree) == out
+
+    def test_tag_deletion_1(self):
+        source = """<root>
+  c1
+  <a>a1<b>a1b</b>a1_</a>
+  c2
+  <a>a2<b>a2b</b>a2_</a>
+  c3
+</root>"""
+        out = """<root>
+  c1
+  <b>a1b</b>
+  c2
+  <a>a2<b>a2b</b>a2_</a>
+  c3
+</root>"""
+        tree = XmlProgram.string_to_tree(source)
+        TagDeletion.do_delete(tree.find('.'), tree.find('./a[1]'))
+        assert XmlProgram.tree_to_string(tree) == out
+
+    def test_tag_deletion_2(self):
+        source = """<root>
+<if>if <cond>(ifcond)</cond> <block>{
+  ... if content ...
+}</block></if>
+<while>while <cond>(whilecond)</cond> <block>{
+  ... while content ...
+}</block></while>
+</root>"""
+        out = """<root>
+<cond>(ifcond)</cond> <block>{
+  ... if content ...
+}</block>
+<while>while <cond>(whilecond)</cond> <block>{
+  ... while content ...
+}</block></while>
+</root>"""
+        tree = XmlProgram.string_to_tree(source)
+        TagDeletion.do_delete(tree.find('.'), tree.find('./if[1]'))
+        assert XmlProgram.tree_to_string(tree) == out
+
+
+    def test_xml_deletion_0(self):
+        source = """<root>
+  c1
+  <a>a1</a>
+  c2
+  <a>a2</a>
+  c3
+</root>"""
+        out = """<root>
+  c1
+  
+  c2
+  <a>a2</a>
+  c3
+</root>"""
+        tree = XmlProgram.string_to_tree(source)
+        XmlDeletion.do_delete(tree.find('.'), tree.find('./a[1]'))
+        assert XmlProgram.tree_to_string(tree) == out
+
+    def test_xml_deletion_1(self):
+        source = """<root>
+  c1
+  <a>a1<b>a1b</b>a1_</a>
+  c2
+  <a>a2<b>a2b</b>a2_</a>
+  c3
+</root>"""
+        out = """<root>
+  c1
+  
+  c2
+  <a>a2<b>a2b</b>a2_</a>
+  c3
+</root>"""
+        tree = XmlProgram.string_to_tree(source)
+        XmlDeletion.do_delete(tree.find('.'), tree.find('./a[1]'))
+        assert XmlProgram.tree_to_string(tree) == out
+
+    def test_xml_deletion_2(self):
+        source = """<root>
+<if>if <cond>(ifcond)</cond> <block>{
+  ... if content ...
+}</block></if>
+<while>while <cond>(whilecond)</cond> <block>{
+  ... while content ...
+}</block></while>
+</root>"""
+        out = """<root>
+
+<while>while <cond>(whilecond)</cond> <block>{
+  ... while content ...
+}</block></while>
+</root>"""
+        tree = XmlProgram.string_to_tree(source)
+        XmlDeletion.do_delete(tree.find('.'), tree.find('./if[1]'))
+        assert XmlProgram.tree_to_string(tree) == out
+
+    def test_tag_insertion_0(self):
+        source = """<root>
+  c1
+  <a>a1</a>
+  c2
+  <a>a2</a>
+  c3
+</root>"""
+        out = """<root>
+  c1
+  <a>a2<a>a1</a></a>
+  c2
+  <a>a2</a>
+  c3
+</root>"""
+        tree = XmlProgram.string_to_tree(source)
+        TagInsertion.do_insert(tree.find('.'), tree.find('./a[1]'), tree.find('./a[2]'))
+        assert XmlProgram.tree_to_string(tree) == out
+
+    def test_tag_insertion_1(self):
+        source = """<root>
+  c1
+  <a>a1<b>a1b</b>a1_</a>
+  c2
+  <a>a2<b>a2b</b>a2_</a>
+  c3
+</root>"""
+        out = """<root>
+  c1
+  <a>a2<a>a1<b>a1b</b>a1_</a>a2_</a>
+  c2
+  <a>a2<b>a2b</b>a2_</a>
+  c3
+</root>"""
+        tree = XmlProgram.string_to_tree(source)
+        TagInsertion.do_insert(tree.find('.'), tree.find('./a[1]'), tree.find('./a[2]'))
+        assert XmlProgram.tree_to_string(tree) == out
+
+    def test_tag_insertion_2(self):
+        source = """<root>
+<if>if <cond>(ifcond)</cond> <block>{
+  ... if content ...
+}</block></if>
+<while>while <cond>(whilecond)</cond> <block>{
+  ... while content ...
+}</block></while>
+</root>"""
+        out = """<root>
+<while>while <if>if <cond>(ifcond)</cond> <block>{
+  ... if content ...
+}</block></if></while>
+<while>while <cond>(whilecond)</cond> <block>{
+  ... while content ...
+}</block></while>
+</root>"""
+        tree = XmlProgram.string_to_tree(source)
+        TagInsertion.do_insert(tree.find('.'), tree.find('./if[1]'), tree.find('./while[1]'))
+        assert XmlProgram.tree_to_string(tree) == out
+
+
+    def test_xml_insertion_0(self):
+        source = """<root>
+  c1
+  <a>a1</a>
+  c2
+  <a>a2</a>
+  c3
+</root>"""
+        out = """<root>
+  c1
+  <a>a1</a><a>a2</a>
+  c2
+  <a>a2</a>
+  c3
+</root>"""
+        tree = XmlProgram.string_to_tree(source)
+        XmlInsertion.do_insert(tree.find('.'), tree.find('./a[1]'), tree.find('./a[2]'))
+        assert XmlProgram.tree_to_string(tree) == out
+
+    def test_xml_insertion_1(self):
+        source = """<root>
+  c1
+  <a>a1<b>a1b</b>a1_</a>
+  c2
+  <a>a2<b>a2b</b>a2_</a>
+  c3
+</root>"""
+        out = """<root>
+  c1
+  <a>a1<b>a1b</b>a1_</a><a>a2<b>a2b</b>a2_</a>
+  c2
+  <a>a2<b>a2b</b>a2_</a>
+  c3
+</root>"""
+        tree = XmlProgram.string_to_tree(source)
+        XmlInsertion.do_insert(tree.find('.'), tree.find('./a[1]'), tree.find('./a[2]'))
+        assert XmlProgram.tree_to_string(tree) == out
+
+    def test_xml_insertion_2(self):
+        source = """<root>
+<if>if <cond>(ifcond)</cond> <block>{
+  ... if content ...
+}</block></if>
+<while>while <cond>(whilecond)</cond> <block>{
+  ... while content ...
+}</block></while>
+</root>"""
+        out = """<root>
+<if>if <cond>(ifcond)</cond> <block>{
+  ... if content ...
+}</block></if><while>while <cond>(whilecond)</cond> <block>{
+  ... while content ...
+}</block></while>
+<while>while <cond>(whilecond)</cond> <block>{
+  ... while content ...
+}</block></while>
+</root>"""
+        tree = XmlProgram.string_to_tree(source)
+        XmlInsertion.do_insert(tree.find('.'), tree.find('./if[1]'), tree.find('./while[1]'))
+        assert XmlProgram.tree_to_string(tree) == out
+
+    def test_xml_insertion_3(self):
+        source = """<root>
+  c1
+  <a>a1</a>
+  c2
+  <a>a2</a>
+  c3
+</root>"""
+        out = """<root>
+  c1
+  <a>a1<a>a2</a></a>
+  c2
+  <a>a2</a>
+  c3
+</root>"""
+        tree = XmlProgram.string_to_tree(source)
+        XmlInsertion.do_insert(tree.find('./a[1]'), None, tree.find('./a[2]'))
+        assert XmlProgram.tree_to_string(tree) == out
+
+    def test_xml_insertion_4(self):
+        source = """<root>
+  c1
+  <a>a1<b>a1b</b>a1_</a>
+  c2
+  <a>a2<b>a2b</b>a2_</a>
+  c3
+</root>"""
+        out = """<root>
+  c1
+  <a>a1<a>a2<b>a2b</b>a2_</a><b>a1b</b>a1_</a>
+  c2
+  <a>a2<b>a2b</b>a2_</a>
+  c3
+</root>"""
+        tree = XmlProgram.string_to_tree(source)
+        XmlInsertion.do_insert(tree.find('./a[1]'), None, tree.find('./a[2]'))
+        assert XmlProgram.tree_to_string(tree) == out
+
+    def test_xml_insertion_5(self):
+        source = """<root>
+<if>if <cond>(ifcond)</cond> <block>{
+  ... if content ...
+}</block></if>
+<while>while <cond>(whilecond)</cond> <block>{
+  ... while content ...
+}</block></while>
+</root>"""
+        out = """<root>
+<if>if <while>while <cond>(whilecond)</cond> <block>{
+  ... while content ...
+}</block></while><cond>(ifcond)</cond> <block>{
+  ... if content ...
+}</block></if>
+<while>while <cond>(whilecond)</cond> <block>{
+  ... while content ...
+}</block></while>
+</root>"""
+        tree = XmlProgram.string_to_tree(source)
+        XmlInsertion.do_insert(tree.find('./if[1]'), None, tree.find('./while[1]'))
+        assert XmlProgram.tree_to_string(tree) == out
+
+    def test_tag_move_0(self):
+        source = """<root>
+  c1
+  <a>a1</a>
+  c2
+  <a>a2</a>
+  c3
+</root>"""
+        out = """<root>
+  c1
+  <a>a2<a>a1</a></a>
+  c2
+  
+  c3
+</root>"""
+        tree = XmlProgram.string_to_tree(source)
+        TagMoving.do_move(tree.find('.'), tree.find('./a[1]'), tree.find('.'), tree.find('./a[2]'))
+        assert XmlProgram.tree_to_string(tree) == out
+
+    def test_tag_move_1(self):
+        source = """<root>
+  c1
+  <a>a1<b>a1b</b>a1_</a>
+  c2
+  <a>a2<b>a2b</b>a2_</a>
+  c3
+</root>"""
+        out = """<root>
+  c1
+  <a>a2<a>a1<b>a1b</b>a1_</a>a2_</a>
+  c2
+  <b>a2b</b>
+  c3
+</root>"""
+        tree = XmlProgram.string_to_tree(source)
+        TagMoving.do_move(tree.find('.'), tree.find('./a[1]'), tree.find('.'), tree.find('./a[2]'))
+        assert XmlProgram.tree_to_string(tree) == out
+
+    def test_tag_move_2(self):
+        source = """<root>
+<if>if <cond>(ifcond)</cond> <block>{
+  ... if content ...
+}</block></if>
+<while>while <cond>(whilecond)</cond> <block>{
+  ... while content ...
+}</block></while>
+</root>"""
+        out = """<root>
+<while>while <if>if <cond>(ifcond)</cond> <block>{
+  ... if content ...
+}</block></if></while>
+<cond>(whilecond)</cond> <block>{
+  ... while content ...
+}</block>
+</root>"""
+        tree = XmlProgram.string_to_tree(source)
+        TagMoving.do_move(tree.find('.'), tree.find('./if[1]'), tree.find('.'), tree.find('./while'))
+        assert XmlProgram.tree_to_string(tree) == out
+
+
+    def test_xml_move_0(self):
+        source = """<root>
+  c1
+  <a>a1</a>
+  c2
+  <a>a2</a>
+  c3
+</root>"""
+        out = """<root>
+  c1
+  <a>a1</a><a>a2</a>
+  c2
+  
+  c3
+</root>"""
+        tree = XmlProgram.string_to_tree(source)
+        XmlMoving.do_move(tree.find('.'), tree.find('./a[1]'), tree.find('.'), tree.find('./a[2]'))
+        print(XmlProgram.tree_to_string(tree))
+        assert XmlProgram.tree_to_string(tree) == out
+
+    def test_xml_move_1(self):
+        source = """<root>
+  c1
+  <a>a1<b>a1b</b>a1_</a>
+  c2
+  <a>a2<b>a2b</b>a2_</a>
+  c3
+</root>"""
+        out = """<root>
+  c1
+  <a>a1<b>a1b</b>a1_</a><a>a2<b>a2b</b>a2_</a>
+  c2
+  
+  c3
+</root>"""
+        tree = XmlProgram.string_to_tree(source)
+        XmlMoving.do_move(tree.find('.'), tree.find('./a[1]'), tree.find('.'), tree.find('./a[2]'))
+        assert XmlProgram.tree_to_string(tree) == out
+
+    def test_xml_move_2(self):
+        source = """<root>
+<if>if <cond>(ifcond)</cond> <block>{
+  ... if content ...
+}</block></if>
+<while>while <cond>(whilecond)</cond> <block>{
+  ... while content ...
+}</block></while>
+</root>"""
+        out = """<root>
+<if>if <cond>(ifcond)</cond> <block>{
+  ... if content ...
+}</block></if><while>while <cond>(whilecond)</cond> <block>{
+  ... while content ...
+}</block></while>
+
+</root>"""
+        tree = XmlProgram.string_to_tree(source)
+        XmlMoving.do_move(tree.find('.'), tree.find('./if[1]'), tree.find('.'), tree.find('./while[1]'))
+        assert XmlProgram.tree_to_string(tree) == out
+
+    def test_xml_move_3(self):
+        source = """<root>
+  c1
+  <a>a1</a>
+  c2
+  <a>a2</a>
+  c3
+</root>"""
+        out = """<root>
+  c1
+  <a>a1<a>a2</a></a>
+  c2
+  
+  c3
+</root>"""
+        tree = XmlProgram.string_to_tree(source)
+        XmlMoving.do_move(tree.find('./a[1]'), None, tree.find('.'), tree.find('./a[2]'))
+        assert XmlProgram.tree_to_string(tree) == out
+
+    def test_xml_move_4(self):
+        source = """<root>
+  c1
+  <a>a1<b>a1b</b>a1_</a>
+  c2
+  <a>a2<b>a2b</b>a2_</a>
+  c3
+</root>"""
+        out = """<root>
+  c1
+  <a>a1<a>a2<b>a2b</b>a2_</a><b>a1b</b>a1_</a>
+  c2
+  
+  c3
+</root>"""
+        tree = XmlProgram.string_to_tree(source)
+        XmlMoving.do_move(tree.find('./a[1]'), None, tree.find('.'), tree.find('./a[2]'))
+        assert XmlProgram.tree_to_string(tree) == out
+
+    def test_xml_move_5(self):
+        source = """<root>
+<if>if <cond>(ifcond)</cond> <block>{
+  ... if content ...
+}</block></if>
+<while>while <cond>(whilecond)</cond> <block>{
+  ... while content ...
+}</block></while>
+</root>"""
+        out = """<root>
+<if>if <while>while <cond>(whilecond)</cond> <block>{
+  ... while content ...
+}</block></while><cond>(ifcond)</cond> <block>{
+  ... if content ...
+}</block></if>
+
+</root>"""
+        tree = XmlProgram.string_to_tree(source)
+        XmlMoving.do_move(tree.find('./if[1]'), None, tree.find('.'), tree.find('./while[1]'))
+        assert XmlProgram.tree_to_string(tree) == out
+
+    def test_tag_swap_0(self):
+        source = """<root>
+  c1
+  <a>a1</a>
+  c2
+  <a>a2</a>
+  c3
+</root>"""
+        out = """<root>
+  c1
+  <a>a2</a>
+  c2
+  <a>a1</a>
+  c3
+</root>"""
+        tree = XmlProgram.string_to_tree(source)
+        TagSwap.do_swap(tree.find('./a[1]'), tree.find('./a[2]'))
+        assert XmlProgram.tree_to_string(tree) == out
+
+    def test_tag_swap_1(self):
+        source = """<root>
+  c1
+  <a>a1<b>a1b</b>a1_</a>
+  c2
+  <a>a2<b>a2b</b>a2_</a>
+  c3
+</root>"""
+        out = """<root>
+  c1
+  <a>a2<b>a1b</b>a2_</a>
+  c2
+  <a>a1<b>a2b</b>a1_</a>
+  c3
+</root>"""
+        tree = XmlProgram.string_to_tree(source)
+        TagSwap.do_swap(tree.find('./a[1]'), tree.find('./a[2]'))
+        assert XmlProgram.tree_to_string(tree) == out
+
+    def test_tag_swap_2(self):
+        source = """<root>
+<if>if <cond>(ifcond)</cond> <block>{
+  ... if content ...
+}</block></if>
+<while>while <cond>(whilecond)</cond> <block>{
+  ... while content ...
+}</block></while>
+</root>"""
+        out = """<root>
+<while>while <cond>(ifcond)</cond> <block>{
+  ... if content ...
+}</block></while>
+<if>if <cond>(whilecond)</cond> <block>{
+  ... while content ...
+}</block></if>
+</root>"""
+        tree = XmlProgram.string_to_tree(source)
+        TagSwap.do_swap(tree.find('./if[1]'), tree.find('./while[1]'))
+        assert XmlProgram.tree_to_string(tree) == out
+
+
+    def test_xml_swap_0(self):
+        source = """<root>
+  c1
+  <a>a1</a>
+  c2
+  <a>a2</a>
+  c3
+</root>"""
+        out = """<root>
+  c1
+  <a>a2</a>
+  c2
+  <a>a1</a>
+  c3
+</root>"""
+        tree = XmlProgram.string_to_tree(source)
+        XmlSwap.do_swap(tree.find('./a[1]'), tree.find('./a[2]'))
+        assert XmlProgram.tree_to_string(tree) == out
+
+    def test_xml_swap_1(self):
+        source = """<root>
+  c1
+  <a>a1<b>a1b</b>a1_</a>
+  c2
+  <a>a2<b>a2b</b>a2_</a>
+  c3
+</root>"""
+        out = """<root>
+  c1
+  <a>a2<b>a2b</b>a2_</a>
+  c2
+  <a>a1<b>a1b</b>a1_</a>
+  c3
+</root>"""
+        tree = XmlProgram.string_to_tree(source)
+        XmlSwap.do_swap(tree.find('./a[1]'), tree.find('./a[2]'))
+        assert XmlProgram.tree_to_string(tree) == out
+
+    def test_xml_swap_2(self):
+        source = """<root>
+<if>if <cond>(ifcond)</cond> <block>{
+  ... if content ...
+}</block></if>
+<while>while <cond>(whilecond)</cond> <block>{
+  ... while content ...
+}</block></while>
+</root>"""
+        out = """<root>
+<while>while <cond>(whilecond)</cond> <block>{
+  ... while content ...
+}</block></while>
+<if>if <cond>(ifcond)</cond> <block>{
+  ... if content ...
+}</block></if>
+</root>"""
+        tree = XmlProgram.string_to_tree(source)
+        XmlSwap.do_swap(tree.find('./if[1]'), tree.find('./while[1]'))
+        assert XmlProgram.tree_to_string(tree) == out
diff --git a/tools/filter_xml_tags.py b/tools/filter_xml_tags.py
new file mode 100644
index 0000000..a2beb60
--- /dev/null
+++ b/tools/filter_xml_tags.py
@@ -0,0 +1,60 @@
+import argparse
+import re
+import sys
+from xml.etree import ElementTree
+
+def append_child(src, tree, child, tags):
+    last = None
+    if child.tag in tags:
+        last = filter_tags(child, tags)
+        tree.append(last)
+    else:
+        if child.tail:
+            if len(child) > 0:
+                *_, last = child
+                if last.tail:
+                    last.tail += child.tail
+                else:
+                    last.tail = child.tail
+            elif child.text:
+                child.text += child.tail
+            else:
+                child.text = child.tail
+        if child.text:
+            if len(tree) > 0:
+                *_, last = tree
+                if last.tail:
+                    last.tail += child.text
+                else:
+                    last.tail = child.text
+            else:
+                if tree.text:
+                    tree.text += child.text
+                else:
+                    tree.text = child.text
+        if len(child) > 0:
+            for subchild in child:
+                append_child(src, tree, subchild, tags)
+    return tree
+
+def filter_tags(tree, tags):
+    filtered = ElementTree.Element(tree.tag, tree.attrib)
+    filtered.text = tree.text
+    filtered.tail = tree.tail
+    for child in tree:
+        filtered = append_child(tree, filtered, child, tags)
+    return filtered
+
+if __name__ == "__main__":
+    parser = argparse.ArgumentParser()
+    parser.add_argument('tags', type=str)
+    parser.add_argument('infile', nargs='?', type=argparse.FileType('r'), default=sys.stdin)
+    parser.add_argument('outfile', nargs='?', type=argparse.FileType('w'), default=sys.stdout)
+    args = parser.parse_args()
+
+    tags = args.tags.split(',')
+    xml = re.sub(r'\s+xmlns="[^"]+"', '', args.infile.read(), count=1)
+    tree = ElementTree.fromstring(xml)
+    tree = filter_tags(tree, tags)
+    print(ElementTree.tostring(tree, encoding='unicode', method='xml'), file=args.outfile)
+
diff --git a/tools/show_points.py b/tools/show_points.py
new file mode 100644
index 0000000..7534448
--- /dev/null
+++ b/tools/show_points.py
@@ -0,0 +1,20 @@
+import argparse
+
+if __name__ == "__main__":
+    parser = argparse.ArgumentParser()
+    parser.add_argument('project_path', type=str, default='../sample/Triangle_fast')
+    parser.add_argument('--line', action='store_true', default=None)
+    parser.add_argument('--ast', action='store_true', default=None)
+    parser.add_argument('--xml', action='store_true', default=None)
+    args = parser.parse_args()
+
+    if args.ast:
+        from pyggi.astor import Program
+    elif args.xml:
+        from pyggi.xml import Program
+    else:
+        from pyggi.line import Program
+
+    program = Program(args.project_path)
+    for target in program.target_files:
+        program.print_modification_points(target)
diff --git a/tools/src_line_to_xml.py b/tools/src_line_to_xml.py
new file mode 100644
index 0000000..ce85e48
--- /dev/null
+++ b/tools/src_line_to_xml.py
@@ -0,0 +1,60 @@
+"""
+src_line_to_xml ::
+
+    python src_line_to_xml.py src_line_to_xml.py
+"""
+import argparse
+import sys
+import xml.sax.saxutils as saxutils
+
+def split_raw(newline, infile, outfile):
+    print('<unit>', end='', file=outfile)
+    if newline:
+        for i, line in enumerate(infile.readlines()):
+            if i > 0:
+                print('</line>', end='')
+            print('<line>{}'.format(saxutils.escape(line.rstrip())), file=outfile)
+        print('</line>')
+    else:
+        for line in infile.readlines():
+            print('<line>{}</line>'.format(saxutils.escape(line.rstrip())), file=outfile)
+    print('</unit>', file=outfile)
+
+def split_better(newline, infile, outfile):
+    print('<unit>', end='', file=outfile)
+    if newline:
+        end = False
+        for line in infile.readlines():
+            if end:
+                print('</line>', end='')
+                end = False
+            if line.strip() != '':
+                print('<line>{}'.format(saxutils.escape(line.rstrip())), file=outfile)
+                end = True
+            else:
+                print(line.rstrip(), file=outfile)
+        if end:
+            print('</line>', end='')
+    else:
+        for line in infile.readlines():
+            if line.strip() != '':
+                print('<line>{}</line>'.format(saxutils.escape(line.rstrip())), file=outfile)
+            else:
+                print(line.rstrip(), file=outfile)
+    print('</unit>', file=outfile)
+
+if __name__ == "__main__":
+    parser = argparse.ArgumentParser()
+    parser.add_argument('--mode', default='better')
+    parser.add_argument('--newline', action='store_true', default=False)
+    parser.add_argument('infile', nargs='?', type=argparse.FileType('r'), default=sys.stdin)
+    parser.add_argument('outfile', nargs='?', type=argparse.FileType('w'), default=sys.stdout)
+    args = parser.parse_args()
+
+    if args.mode == 'raw':
+        split_raw(args.newline, args.infile, args.outfile)
+    elif args.mode == 'better':
+        split_better(args.newline, args.infile, args.outfile)
+    else:
+        print('ERROR: --mode should be either "raw" or "better"', file=sys.stderr)
+        exit(1)
diff --git a/tools/strip_xml.py b/tools/strip_xml.py
new file mode 100644
index 0000000..83d266e
--- /dev/null
+++ b/tools/strip_xml.py
@@ -0,0 +1,11 @@
+import argparse
+import sys
+from pyggi.xml import Program
+
+if __name__ == "__main__":
+    parser = argparse.ArgumentParser()
+    parser.add_argument('infile', nargs='?', type=argparse.FileType('r'), default=sys.stdin)
+    parser.add_argument('outfile', nargs='?', type=argparse.FileType('w'), default=sys.stdout)
+    args = parser.parse_args()
+
+    print(Program.strip_xml_from_string(args.infile.read()), file=args.outfile)
